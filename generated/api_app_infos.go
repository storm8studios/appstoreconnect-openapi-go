/*
App Store Connect API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package appstoreopenapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// AppInfosApiService AppInfosApi service
type AppInfosApiService service

type AppInfosApiAppInfosAgeRatingDeclarationGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppInfosApiService
	id string
	fieldsAgeRatingDeclarations *[]string
}

// the fields to include for returned resources of type ageRatingDeclarations
func (r AppInfosApiAppInfosAgeRatingDeclarationGetToOneRelatedRequest) FieldsAgeRatingDeclarations(fieldsAgeRatingDeclarations []string) AppInfosApiAppInfosAgeRatingDeclarationGetToOneRelatedRequest {
	r.fieldsAgeRatingDeclarations = &fieldsAgeRatingDeclarations
	return r
}

func (r AppInfosApiAppInfosAgeRatingDeclarationGetToOneRelatedRequest) Execute() (*AgeRatingDeclarationResponse, *http.Response, error) {
	return r.ApiService.AppInfosAgeRatingDeclarationGetToOneRelatedExecute(r)
}

/*
AppInfosAgeRatingDeclarationGetToOneRelated Method for AppInfosAgeRatingDeclarationGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppInfosApiAppInfosAgeRatingDeclarationGetToOneRelatedRequest
*/
func (a *AppInfosApiService) AppInfosAgeRatingDeclarationGetToOneRelated(ctx context.Context, id string) AppInfosApiAppInfosAgeRatingDeclarationGetToOneRelatedRequest {
	return AppInfosApiAppInfosAgeRatingDeclarationGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AgeRatingDeclarationResponse
func (a *AppInfosApiService) AppInfosAgeRatingDeclarationGetToOneRelatedExecute(r AppInfosApiAppInfosAgeRatingDeclarationGetToOneRelatedRequest) (*AgeRatingDeclarationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AgeRatingDeclarationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppInfosApiService.AppInfosAgeRatingDeclarationGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appInfos/{id}/ageRatingDeclaration"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAgeRatingDeclarations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[ageRatingDeclarations]", r.fieldsAgeRatingDeclarations, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppInfosApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppInfosApiService
	id string
	filterLocale *[]string
	fieldsAppInfos *[]string
	fieldsAppInfoLocalizations *[]string
	limit *int32
	include *[]string
}

// filter by attribute &#39;locale&#39;
func (r AppInfosApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest) FilterLocale(filterLocale []string) AppInfosApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest {
	r.filterLocale = &filterLocale
	return r
}

// the fields to include for returned resources of type appInfos
func (r AppInfosApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest) FieldsAppInfos(fieldsAppInfos []string) AppInfosApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest {
	r.fieldsAppInfos = &fieldsAppInfos
	return r
}

// the fields to include for returned resources of type appInfoLocalizations
func (r AppInfosApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest) FieldsAppInfoLocalizations(fieldsAppInfoLocalizations []string) AppInfosApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest {
	r.fieldsAppInfoLocalizations = &fieldsAppInfoLocalizations
	return r
}

// maximum resources per page
func (r AppInfosApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest) Limit(limit int32) AppInfosApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r AppInfosApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest) Include(include []string) AppInfosApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r AppInfosApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest) Execute() (*AppInfoLocalizationsResponse, *http.Response, error) {
	return r.ApiService.AppInfosAppInfoLocalizationsGetToManyRelatedExecute(r)
}

/*
AppInfosAppInfoLocalizationsGetToManyRelated Method for AppInfosAppInfoLocalizationsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppInfosApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest
*/
func (a *AppInfosApiService) AppInfosAppInfoLocalizationsGetToManyRelated(ctx context.Context, id string) AppInfosApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest {
	return AppInfosApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppInfoLocalizationsResponse
func (a *AppInfosApiService) AppInfosAppInfoLocalizationsGetToManyRelatedExecute(r AppInfosApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest) (*AppInfoLocalizationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppInfoLocalizationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppInfosApiService.AppInfosAppInfoLocalizationsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appInfos/{id}/appInfoLocalizations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterLocale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[locale]", r.filterLocale, "csv")
	}
	if r.fieldsAppInfos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appInfos]", r.fieldsAppInfos, "csv")
	}
	if r.fieldsAppInfoLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appInfoLocalizations]", r.fieldsAppInfoLocalizations, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppInfosApiAppInfosGetInstanceRequest struct {
	ctx context.Context
	ApiService *AppInfosApiService
	id string
	fieldsAppInfos *[]string
	include *[]string
	fieldsAgeRatingDeclarations *[]string
	fieldsAppInfoLocalizations *[]string
	fieldsAppCategories *[]string
	limitAppInfoLocalizations *int32
}

// the fields to include for returned resources of type appInfos
func (r AppInfosApiAppInfosGetInstanceRequest) FieldsAppInfos(fieldsAppInfos []string) AppInfosApiAppInfosGetInstanceRequest {
	r.fieldsAppInfos = &fieldsAppInfos
	return r
}

// comma-separated list of relationships to include
func (r AppInfosApiAppInfosGetInstanceRequest) Include(include []string) AppInfosApiAppInfosGetInstanceRequest {
	r.include = &include
	return r
}

// the fields to include for returned resources of type ageRatingDeclarations
func (r AppInfosApiAppInfosGetInstanceRequest) FieldsAgeRatingDeclarations(fieldsAgeRatingDeclarations []string) AppInfosApiAppInfosGetInstanceRequest {
	r.fieldsAgeRatingDeclarations = &fieldsAgeRatingDeclarations
	return r
}

// the fields to include for returned resources of type appInfoLocalizations
func (r AppInfosApiAppInfosGetInstanceRequest) FieldsAppInfoLocalizations(fieldsAppInfoLocalizations []string) AppInfosApiAppInfosGetInstanceRequest {
	r.fieldsAppInfoLocalizations = &fieldsAppInfoLocalizations
	return r
}

// the fields to include for returned resources of type appCategories
func (r AppInfosApiAppInfosGetInstanceRequest) FieldsAppCategories(fieldsAppCategories []string) AppInfosApiAppInfosGetInstanceRequest {
	r.fieldsAppCategories = &fieldsAppCategories
	return r
}

// maximum number of related appInfoLocalizations returned (when they are included)
func (r AppInfosApiAppInfosGetInstanceRequest) LimitAppInfoLocalizations(limitAppInfoLocalizations int32) AppInfosApiAppInfosGetInstanceRequest {
	r.limitAppInfoLocalizations = &limitAppInfoLocalizations
	return r
}

func (r AppInfosApiAppInfosGetInstanceRequest) Execute() (*AppInfoResponse, *http.Response, error) {
	return r.ApiService.AppInfosGetInstanceExecute(r)
}

/*
AppInfosGetInstance Method for AppInfosGetInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppInfosApiAppInfosGetInstanceRequest
*/
func (a *AppInfosApiService) AppInfosGetInstance(ctx context.Context, id string) AppInfosApiAppInfosGetInstanceRequest {
	return AppInfosApiAppInfosGetInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppInfoResponse
func (a *AppInfosApiService) AppInfosGetInstanceExecute(r AppInfosApiAppInfosGetInstanceRequest) (*AppInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppInfosApiService.AppInfosGetInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appInfos/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppInfos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appInfos]", r.fieldsAppInfos, "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	if r.fieldsAgeRatingDeclarations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[ageRatingDeclarations]", r.fieldsAgeRatingDeclarations, "csv")
	}
	if r.fieldsAppInfoLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appInfoLocalizations]", r.fieldsAppInfoLocalizations, "csv")
	}
	if r.fieldsAppCategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCategories]", r.fieldsAppCategories, "csv")
	}
	if r.limitAppInfoLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appInfoLocalizations]", r.limitAppInfoLocalizations, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppInfosApiAppInfosPrimaryCategoryGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppInfosApiService
	id string
	fieldsAppCategories *[]string
	limitSubcategories *int32
	include *[]string
}

// the fields to include for returned resources of type appCategories
func (r AppInfosApiAppInfosPrimaryCategoryGetToOneRelatedRequest) FieldsAppCategories(fieldsAppCategories []string) AppInfosApiAppInfosPrimaryCategoryGetToOneRelatedRequest {
	r.fieldsAppCategories = &fieldsAppCategories
	return r
}

// maximum number of related subcategories returned (when they are included)
func (r AppInfosApiAppInfosPrimaryCategoryGetToOneRelatedRequest) LimitSubcategories(limitSubcategories int32) AppInfosApiAppInfosPrimaryCategoryGetToOneRelatedRequest {
	r.limitSubcategories = &limitSubcategories
	return r
}

// comma-separated list of relationships to include
func (r AppInfosApiAppInfosPrimaryCategoryGetToOneRelatedRequest) Include(include []string) AppInfosApiAppInfosPrimaryCategoryGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r AppInfosApiAppInfosPrimaryCategoryGetToOneRelatedRequest) Execute() (*AppCategoryResponse, *http.Response, error) {
	return r.ApiService.AppInfosPrimaryCategoryGetToOneRelatedExecute(r)
}

/*
AppInfosPrimaryCategoryGetToOneRelated Method for AppInfosPrimaryCategoryGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppInfosApiAppInfosPrimaryCategoryGetToOneRelatedRequest
*/
func (a *AppInfosApiService) AppInfosPrimaryCategoryGetToOneRelated(ctx context.Context, id string) AppInfosApiAppInfosPrimaryCategoryGetToOneRelatedRequest {
	return AppInfosApiAppInfosPrimaryCategoryGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppCategoryResponse
func (a *AppInfosApiService) AppInfosPrimaryCategoryGetToOneRelatedExecute(r AppInfosApiAppInfosPrimaryCategoryGetToOneRelatedRequest) (*AppCategoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppCategoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppInfosApiService.AppInfosPrimaryCategoryGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appInfos/{id}/primaryCategory"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppCategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCategories]", r.fieldsAppCategories, "csv")
	}
	if r.limitSubcategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subcategories]", r.limitSubcategories, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppInfosApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppInfosApiService
	id string
	fieldsAppCategories *[]string
	limitSubcategories *int32
	include *[]string
}

// the fields to include for returned resources of type appCategories
func (r AppInfosApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest) FieldsAppCategories(fieldsAppCategories []string) AppInfosApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest {
	r.fieldsAppCategories = &fieldsAppCategories
	return r
}

// maximum number of related subcategories returned (when they are included)
func (r AppInfosApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest) LimitSubcategories(limitSubcategories int32) AppInfosApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest {
	r.limitSubcategories = &limitSubcategories
	return r
}

// comma-separated list of relationships to include
func (r AppInfosApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest) Include(include []string) AppInfosApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r AppInfosApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest) Execute() (*AppCategoryResponse, *http.Response, error) {
	return r.ApiService.AppInfosPrimarySubcategoryOneGetToOneRelatedExecute(r)
}

/*
AppInfosPrimarySubcategoryOneGetToOneRelated Method for AppInfosPrimarySubcategoryOneGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppInfosApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest
*/
func (a *AppInfosApiService) AppInfosPrimarySubcategoryOneGetToOneRelated(ctx context.Context, id string) AppInfosApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest {
	return AppInfosApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppCategoryResponse
func (a *AppInfosApiService) AppInfosPrimarySubcategoryOneGetToOneRelatedExecute(r AppInfosApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest) (*AppCategoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppCategoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppInfosApiService.AppInfosPrimarySubcategoryOneGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appInfos/{id}/primarySubcategoryOne"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppCategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCategories]", r.fieldsAppCategories, "csv")
	}
	if r.limitSubcategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subcategories]", r.limitSubcategories, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppInfosApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppInfosApiService
	id string
	fieldsAppCategories *[]string
	limitSubcategories *int32
	include *[]string
}

// the fields to include for returned resources of type appCategories
func (r AppInfosApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest) FieldsAppCategories(fieldsAppCategories []string) AppInfosApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest {
	r.fieldsAppCategories = &fieldsAppCategories
	return r
}

// maximum number of related subcategories returned (when they are included)
func (r AppInfosApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest) LimitSubcategories(limitSubcategories int32) AppInfosApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest {
	r.limitSubcategories = &limitSubcategories
	return r
}

// comma-separated list of relationships to include
func (r AppInfosApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest) Include(include []string) AppInfosApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r AppInfosApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest) Execute() (*AppCategoryResponse, *http.Response, error) {
	return r.ApiService.AppInfosPrimarySubcategoryTwoGetToOneRelatedExecute(r)
}

/*
AppInfosPrimarySubcategoryTwoGetToOneRelated Method for AppInfosPrimarySubcategoryTwoGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppInfosApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest
*/
func (a *AppInfosApiService) AppInfosPrimarySubcategoryTwoGetToOneRelated(ctx context.Context, id string) AppInfosApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest {
	return AppInfosApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppCategoryResponse
func (a *AppInfosApiService) AppInfosPrimarySubcategoryTwoGetToOneRelatedExecute(r AppInfosApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest) (*AppCategoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppCategoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppInfosApiService.AppInfosPrimarySubcategoryTwoGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appInfos/{id}/primarySubcategoryTwo"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppCategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCategories]", r.fieldsAppCategories, "csv")
	}
	if r.limitSubcategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subcategories]", r.limitSubcategories, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppInfosApiAppInfosSecondaryCategoryGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppInfosApiService
	id string
	fieldsAppCategories *[]string
	limitSubcategories *int32
	include *[]string
}

// the fields to include for returned resources of type appCategories
func (r AppInfosApiAppInfosSecondaryCategoryGetToOneRelatedRequest) FieldsAppCategories(fieldsAppCategories []string) AppInfosApiAppInfosSecondaryCategoryGetToOneRelatedRequest {
	r.fieldsAppCategories = &fieldsAppCategories
	return r
}

// maximum number of related subcategories returned (when they are included)
func (r AppInfosApiAppInfosSecondaryCategoryGetToOneRelatedRequest) LimitSubcategories(limitSubcategories int32) AppInfosApiAppInfosSecondaryCategoryGetToOneRelatedRequest {
	r.limitSubcategories = &limitSubcategories
	return r
}

// comma-separated list of relationships to include
func (r AppInfosApiAppInfosSecondaryCategoryGetToOneRelatedRequest) Include(include []string) AppInfosApiAppInfosSecondaryCategoryGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r AppInfosApiAppInfosSecondaryCategoryGetToOneRelatedRequest) Execute() (*AppCategoryResponse, *http.Response, error) {
	return r.ApiService.AppInfosSecondaryCategoryGetToOneRelatedExecute(r)
}

/*
AppInfosSecondaryCategoryGetToOneRelated Method for AppInfosSecondaryCategoryGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppInfosApiAppInfosSecondaryCategoryGetToOneRelatedRequest
*/
func (a *AppInfosApiService) AppInfosSecondaryCategoryGetToOneRelated(ctx context.Context, id string) AppInfosApiAppInfosSecondaryCategoryGetToOneRelatedRequest {
	return AppInfosApiAppInfosSecondaryCategoryGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppCategoryResponse
func (a *AppInfosApiService) AppInfosSecondaryCategoryGetToOneRelatedExecute(r AppInfosApiAppInfosSecondaryCategoryGetToOneRelatedRequest) (*AppCategoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppCategoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppInfosApiService.AppInfosSecondaryCategoryGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appInfos/{id}/secondaryCategory"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppCategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCategories]", r.fieldsAppCategories, "csv")
	}
	if r.limitSubcategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subcategories]", r.limitSubcategories, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppInfosApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppInfosApiService
	id string
	fieldsAppCategories *[]string
	limitSubcategories *int32
	include *[]string
}

// the fields to include for returned resources of type appCategories
func (r AppInfosApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest) FieldsAppCategories(fieldsAppCategories []string) AppInfosApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest {
	r.fieldsAppCategories = &fieldsAppCategories
	return r
}

// maximum number of related subcategories returned (when they are included)
func (r AppInfosApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest) LimitSubcategories(limitSubcategories int32) AppInfosApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest {
	r.limitSubcategories = &limitSubcategories
	return r
}

// comma-separated list of relationships to include
func (r AppInfosApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest) Include(include []string) AppInfosApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r AppInfosApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest) Execute() (*AppCategoryResponse, *http.Response, error) {
	return r.ApiService.AppInfosSecondarySubcategoryOneGetToOneRelatedExecute(r)
}

/*
AppInfosSecondarySubcategoryOneGetToOneRelated Method for AppInfosSecondarySubcategoryOneGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppInfosApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest
*/
func (a *AppInfosApiService) AppInfosSecondarySubcategoryOneGetToOneRelated(ctx context.Context, id string) AppInfosApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest {
	return AppInfosApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppCategoryResponse
func (a *AppInfosApiService) AppInfosSecondarySubcategoryOneGetToOneRelatedExecute(r AppInfosApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest) (*AppCategoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppCategoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppInfosApiService.AppInfosSecondarySubcategoryOneGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appInfos/{id}/secondarySubcategoryOne"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppCategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCategories]", r.fieldsAppCategories, "csv")
	}
	if r.limitSubcategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subcategories]", r.limitSubcategories, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppInfosApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppInfosApiService
	id string
	fieldsAppCategories *[]string
	limitSubcategories *int32
	include *[]string
}

// the fields to include for returned resources of type appCategories
func (r AppInfosApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest) FieldsAppCategories(fieldsAppCategories []string) AppInfosApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest {
	r.fieldsAppCategories = &fieldsAppCategories
	return r
}

// maximum number of related subcategories returned (when they are included)
func (r AppInfosApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest) LimitSubcategories(limitSubcategories int32) AppInfosApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest {
	r.limitSubcategories = &limitSubcategories
	return r
}

// comma-separated list of relationships to include
func (r AppInfosApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest) Include(include []string) AppInfosApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r AppInfosApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest) Execute() (*AppCategoryResponse, *http.Response, error) {
	return r.ApiService.AppInfosSecondarySubcategoryTwoGetToOneRelatedExecute(r)
}

/*
AppInfosSecondarySubcategoryTwoGetToOneRelated Method for AppInfosSecondarySubcategoryTwoGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppInfosApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest
*/
func (a *AppInfosApiService) AppInfosSecondarySubcategoryTwoGetToOneRelated(ctx context.Context, id string) AppInfosApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest {
	return AppInfosApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppCategoryResponse
func (a *AppInfosApiService) AppInfosSecondarySubcategoryTwoGetToOneRelatedExecute(r AppInfosApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest) (*AppCategoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppCategoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppInfosApiService.AppInfosSecondarySubcategoryTwoGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appInfos/{id}/secondarySubcategoryTwo"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppCategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCategories]", r.fieldsAppCategories, "csv")
	}
	if r.limitSubcategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subcategories]", r.limitSubcategories, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppInfosApiAppInfosUpdateInstanceRequest struct {
	ctx context.Context
	ApiService *AppInfosApiService
	id string
	appInfoUpdateRequest *AppInfoUpdateRequest
}

// AppInfo representation
func (r AppInfosApiAppInfosUpdateInstanceRequest) AppInfoUpdateRequest(appInfoUpdateRequest AppInfoUpdateRequest) AppInfosApiAppInfosUpdateInstanceRequest {
	r.appInfoUpdateRequest = &appInfoUpdateRequest
	return r
}

func (r AppInfosApiAppInfosUpdateInstanceRequest) Execute() (*AppInfoResponse, *http.Response, error) {
	return r.ApiService.AppInfosUpdateInstanceExecute(r)
}

/*
AppInfosUpdateInstance Method for AppInfosUpdateInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppInfosApiAppInfosUpdateInstanceRequest
*/
func (a *AppInfosApiService) AppInfosUpdateInstance(ctx context.Context, id string) AppInfosApiAppInfosUpdateInstanceRequest {
	return AppInfosApiAppInfosUpdateInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppInfoResponse
func (a *AppInfosApiService) AppInfosUpdateInstanceExecute(r AppInfosApiAppInfosUpdateInstanceRequest) (*AppInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppInfosApiService.AppInfosUpdateInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appInfos/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appInfoUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("appInfoUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appInfoUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
