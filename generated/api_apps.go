/*
App Store Connect API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package appstoreopenapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// AppsApiService AppsApi service
type AppsApiService service

type AppsApiAppsAppAvailabilityGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	fieldsAppAvailabilities *[]string
	fieldsApps *[]string
	fieldsTerritories *[]string
	limitAvailableTerritories *int32
	include *[]string
}

// the fields to include for returned resources of type appAvailabilities
func (r AppsApiAppsAppAvailabilityGetToOneRelatedRequest) FieldsAppAvailabilities(fieldsAppAvailabilities []string) AppsApiAppsAppAvailabilityGetToOneRelatedRequest {
	r.fieldsAppAvailabilities = &fieldsAppAvailabilities
	return r
}

// the fields to include for returned resources of type apps
func (r AppsApiAppsAppAvailabilityGetToOneRelatedRequest) FieldsApps(fieldsApps []string) AppsApiAppsAppAvailabilityGetToOneRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type territories
func (r AppsApiAppsAppAvailabilityGetToOneRelatedRequest) FieldsTerritories(fieldsTerritories []string) AppsApiAppsAppAvailabilityGetToOneRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// maximum number of related availableTerritories returned (when they are included)
func (r AppsApiAppsAppAvailabilityGetToOneRelatedRequest) LimitAvailableTerritories(limitAvailableTerritories int32) AppsApiAppsAppAvailabilityGetToOneRelatedRequest {
	r.limitAvailableTerritories = &limitAvailableTerritories
	return r
}

// comma-separated list of relationships to include
func (r AppsApiAppsAppAvailabilityGetToOneRelatedRequest) Include(include []string) AppsApiAppsAppAvailabilityGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r AppsApiAppsAppAvailabilityGetToOneRelatedRequest) Execute() (*AppAvailabilityResponse, *http.Response, error) {
	return r.ApiService.AppsAppAvailabilityGetToOneRelatedExecute(r)
}

/*
AppsAppAvailabilityGetToOneRelated Method for AppsAppAvailabilityGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsAppAvailabilityGetToOneRelatedRequest
*/
func (a *AppsApiService) AppsAppAvailabilityGetToOneRelated(ctx context.Context, id string) AppsApiAppsAppAvailabilityGetToOneRelatedRequest {
	return AppsApiAppsAppAvailabilityGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppAvailabilityResponse
func (a *AppsApiService) AppsAppAvailabilityGetToOneRelatedExecute(r AppsApiAppsAppAvailabilityGetToOneRelatedRequest) (*AppAvailabilityResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppAvailabilityResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsAppAvailabilityGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/appAvailability"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppAvailabilities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appAvailabilities]", r.fieldsAppAvailabilities, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "csv")
	}
	if r.limitAvailableTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[availableTerritories]", r.limitAvailableTerritories, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsAppClipsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	filterBundleId *[]string
	fieldsAppClips *[]string
	fieldsApps *[]string
	fieldsAppClipDefaultExperiences *[]string
	limit *int32
	limitAppClipDefaultExperiences *int32
	include *[]string
}

// filter by attribute &#39;bundleId&#39;
func (r AppsApiAppsAppClipsGetToManyRelatedRequest) FilterBundleId(filterBundleId []string) AppsApiAppsAppClipsGetToManyRelatedRequest {
	r.filterBundleId = &filterBundleId
	return r
}

// the fields to include for returned resources of type appClips
func (r AppsApiAppsAppClipsGetToManyRelatedRequest) FieldsAppClips(fieldsAppClips []string) AppsApiAppsAppClipsGetToManyRelatedRequest {
	r.fieldsAppClips = &fieldsAppClips
	return r
}

// the fields to include for returned resources of type apps
func (r AppsApiAppsAppClipsGetToManyRelatedRequest) FieldsApps(fieldsApps []string) AppsApiAppsAppClipsGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type appClipDefaultExperiences
func (r AppsApiAppsAppClipsGetToManyRelatedRequest) FieldsAppClipDefaultExperiences(fieldsAppClipDefaultExperiences []string) AppsApiAppsAppClipsGetToManyRelatedRequest {
	r.fieldsAppClipDefaultExperiences = &fieldsAppClipDefaultExperiences
	return r
}

// maximum resources per page
func (r AppsApiAppsAppClipsGetToManyRelatedRequest) Limit(limit int32) AppsApiAppsAppClipsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// maximum number of related appClipDefaultExperiences returned (when they are included)
func (r AppsApiAppsAppClipsGetToManyRelatedRequest) LimitAppClipDefaultExperiences(limitAppClipDefaultExperiences int32) AppsApiAppsAppClipsGetToManyRelatedRequest {
	r.limitAppClipDefaultExperiences = &limitAppClipDefaultExperiences
	return r
}

// comma-separated list of relationships to include
func (r AppsApiAppsAppClipsGetToManyRelatedRequest) Include(include []string) AppsApiAppsAppClipsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r AppsApiAppsAppClipsGetToManyRelatedRequest) Execute() (*AppClipsResponse, *http.Response, error) {
	return r.ApiService.AppsAppClipsGetToManyRelatedExecute(r)
}

/*
AppsAppClipsGetToManyRelated Method for AppsAppClipsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsAppClipsGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsAppClipsGetToManyRelated(ctx context.Context, id string) AppsApiAppsAppClipsGetToManyRelatedRequest {
	return AppsApiAppsAppClipsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppClipsResponse
func (a *AppsApiService) AppsAppClipsGetToManyRelatedExecute(r AppsApiAppsAppClipsGetToManyRelatedRequest) (*AppClipsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppClipsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsAppClipsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/appClips"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterBundleId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[bundleId]", r.filterBundleId, "csv")
	}
	if r.fieldsAppClips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appClips]", r.fieldsAppClips, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.fieldsAppClipDefaultExperiences != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appClipDefaultExperiences]", r.fieldsAppClipDefaultExperiences, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.limitAppClipDefaultExperiences != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appClipDefaultExperiences]", r.limitAppClipDefaultExperiences, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsAppCustomProductPagesGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	filterVisible *[]string
	fieldsAppCustomProductPages *[]string
	fieldsAppCustomProductPageVersions *[]string
	fieldsApps *[]string
	limit *int32
	limitAppCustomProductPageVersions *int32
	include *[]string
}

// filter by attribute &#39;visible&#39;
func (r AppsApiAppsAppCustomProductPagesGetToManyRelatedRequest) FilterVisible(filterVisible []string) AppsApiAppsAppCustomProductPagesGetToManyRelatedRequest {
	r.filterVisible = &filterVisible
	return r
}

// the fields to include for returned resources of type appCustomProductPages
func (r AppsApiAppsAppCustomProductPagesGetToManyRelatedRequest) FieldsAppCustomProductPages(fieldsAppCustomProductPages []string) AppsApiAppsAppCustomProductPagesGetToManyRelatedRequest {
	r.fieldsAppCustomProductPages = &fieldsAppCustomProductPages
	return r
}

// the fields to include for returned resources of type appCustomProductPageVersions
func (r AppsApiAppsAppCustomProductPagesGetToManyRelatedRequest) FieldsAppCustomProductPageVersions(fieldsAppCustomProductPageVersions []string) AppsApiAppsAppCustomProductPagesGetToManyRelatedRequest {
	r.fieldsAppCustomProductPageVersions = &fieldsAppCustomProductPageVersions
	return r
}

// the fields to include for returned resources of type apps
func (r AppsApiAppsAppCustomProductPagesGetToManyRelatedRequest) FieldsApps(fieldsApps []string) AppsApiAppsAppCustomProductPagesGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// maximum resources per page
func (r AppsApiAppsAppCustomProductPagesGetToManyRelatedRequest) Limit(limit int32) AppsApiAppsAppCustomProductPagesGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// maximum number of related appCustomProductPageVersions returned (when they are included)
func (r AppsApiAppsAppCustomProductPagesGetToManyRelatedRequest) LimitAppCustomProductPageVersions(limitAppCustomProductPageVersions int32) AppsApiAppsAppCustomProductPagesGetToManyRelatedRequest {
	r.limitAppCustomProductPageVersions = &limitAppCustomProductPageVersions
	return r
}

// comma-separated list of relationships to include
func (r AppsApiAppsAppCustomProductPagesGetToManyRelatedRequest) Include(include []string) AppsApiAppsAppCustomProductPagesGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r AppsApiAppsAppCustomProductPagesGetToManyRelatedRequest) Execute() (*AppCustomProductPagesResponse, *http.Response, error) {
	return r.ApiService.AppsAppCustomProductPagesGetToManyRelatedExecute(r)
}

/*
AppsAppCustomProductPagesGetToManyRelated Method for AppsAppCustomProductPagesGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsAppCustomProductPagesGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsAppCustomProductPagesGetToManyRelated(ctx context.Context, id string) AppsApiAppsAppCustomProductPagesGetToManyRelatedRequest {
	return AppsApiAppsAppCustomProductPagesGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppCustomProductPagesResponse
func (a *AppsApiService) AppsAppCustomProductPagesGetToManyRelatedExecute(r AppsApiAppsAppCustomProductPagesGetToManyRelatedRequest) (*AppCustomProductPagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppCustomProductPagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsAppCustomProductPagesGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/appCustomProductPages"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterVisible != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[visible]", r.filterVisible, "csv")
	}
	if r.fieldsAppCustomProductPages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCustomProductPages]", r.fieldsAppCustomProductPages, "csv")
	}
	if r.fieldsAppCustomProductPageVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCustomProductPageVersions]", r.fieldsAppCustomProductPageVersions, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.limitAppCustomProductPageVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appCustomProductPageVersions]", r.limitAppCustomProductPageVersions, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsAppEventsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	filterEventState *[]string
	filterId *[]string
	fieldsAppEventLocalizations *[]string
	fieldsAppEvents *[]string
	limit *int32
	limitLocalizations *int32
	include *[]string
}

// filter by attribute &#39;eventState&#39;
func (r AppsApiAppsAppEventsGetToManyRelatedRequest) FilterEventState(filterEventState []string) AppsApiAppsAppEventsGetToManyRelatedRequest {
	r.filterEventState = &filterEventState
	return r
}

// filter by id(s)
func (r AppsApiAppsAppEventsGetToManyRelatedRequest) FilterId(filterId []string) AppsApiAppsAppEventsGetToManyRelatedRequest {
	r.filterId = &filterId
	return r
}

// the fields to include for returned resources of type appEventLocalizations
func (r AppsApiAppsAppEventsGetToManyRelatedRequest) FieldsAppEventLocalizations(fieldsAppEventLocalizations []string) AppsApiAppsAppEventsGetToManyRelatedRequest {
	r.fieldsAppEventLocalizations = &fieldsAppEventLocalizations
	return r
}

// the fields to include for returned resources of type appEvents
func (r AppsApiAppsAppEventsGetToManyRelatedRequest) FieldsAppEvents(fieldsAppEvents []string) AppsApiAppsAppEventsGetToManyRelatedRequest {
	r.fieldsAppEvents = &fieldsAppEvents
	return r
}

// maximum resources per page
func (r AppsApiAppsAppEventsGetToManyRelatedRequest) Limit(limit int32) AppsApiAppsAppEventsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// maximum number of related localizations returned (when they are included)
func (r AppsApiAppsAppEventsGetToManyRelatedRequest) LimitLocalizations(limitLocalizations int32) AppsApiAppsAppEventsGetToManyRelatedRequest {
	r.limitLocalizations = &limitLocalizations
	return r
}

// comma-separated list of relationships to include
func (r AppsApiAppsAppEventsGetToManyRelatedRequest) Include(include []string) AppsApiAppsAppEventsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r AppsApiAppsAppEventsGetToManyRelatedRequest) Execute() (*AppEventsResponse, *http.Response, error) {
	return r.ApiService.AppsAppEventsGetToManyRelatedExecute(r)
}

/*
AppsAppEventsGetToManyRelated Method for AppsAppEventsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsAppEventsGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsAppEventsGetToManyRelated(ctx context.Context, id string) AppsApiAppsAppEventsGetToManyRelatedRequest {
	return AppsApiAppsAppEventsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppEventsResponse
func (a *AppsApiService) AppsAppEventsGetToManyRelatedExecute(r AppsApiAppsAppEventsGetToManyRelatedRequest) (*AppEventsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppEventsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsAppEventsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/appEvents"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterEventState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[eventState]", r.filterEventState, "csv")
	}
	if r.filterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[id]", r.filterId, "csv")
	}
	if r.fieldsAppEventLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appEventLocalizations]", r.fieldsAppEventLocalizations, "csv")
	}
	if r.fieldsAppEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appEvents]", r.fieldsAppEvents, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.limitLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[localizations]", r.limitLocalizations, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsAppInfosGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	fieldsAgeRatingDeclarations *[]string
	fieldsAppInfos *[]string
	fieldsAppInfoLocalizations *[]string
	fieldsAppCategories *[]string
	fieldsApps *[]string
	limit *int32
	limitAppInfoLocalizations *int32
	include *[]string
}

// the fields to include for returned resources of type ageRatingDeclarations
func (r AppsApiAppsAppInfosGetToManyRelatedRequest) FieldsAgeRatingDeclarations(fieldsAgeRatingDeclarations []string) AppsApiAppsAppInfosGetToManyRelatedRequest {
	r.fieldsAgeRatingDeclarations = &fieldsAgeRatingDeclarations
	return r
}

// the fields to include for returned resources of type appInfos
func (r AppsApiAppsAppInfosGetToManyRelatedRequest) FieldsAppInfos(fieldsAppInfos []string) AppsApiAppsAppInfosGetToManyRelatedRequest {
	r.fieldsAppInfos = &fieldsAppInfos
	return r
}

// the fields to include for returned resources of type appInfoLocalizations
func (r AppsApiAppsAppInfosGetToManyRelatedRequest) FieldsAppInfoLocalizations(fieldsAppInfoLocalizations []string) AppsApiAppsAppInfosGetToManyRelatedRequest {
	r.fieldsAppInfoLocalizations = &fieldsAppInfoLocalizations
	return r
}

// the fields to include for returned resources of type appCategories
func (r AppsApiAppsAppInfosGetToManyRelatedRequest) FieldsAppCategories(fieldsAppCategories []string) AppsApiAppsAppInfosGetToManyRelatedRequest {
	r.fieldsAppCategories = &fieldsAppCategories
	return r
}

// the fields to include for returned resources of type apps
func (r AppsApiAppsAppInfosGetToManyRelatedRequest) FieldsApps(fieldsApps []string) AppsApiAppsAppInfosGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// maximum resources per page
func (r AppsApiAppsAppInfosGetToManyRelatedRequest) Limit(limit int32) AppsApiAppsAppInfosGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// maximum number of related appInfoLocalizations returned (when they are included)
func (r AppsApiAppsAppInfosGetToManyRelatedRequest) LimitAppInfoLocalizations(limitAppInfoLocalizations int32) AppsApiAppsAppInfosGetToManyRelatedRequest {
	r.limitAppInfoLocalizations = &limitAppInfoLocalizations
	return r
}

// comma-separated list of relationships to include
func (r AppsApiAppsAppInfosGetToManyRelatedRequest) Include(include []string) AppsApiAppsAppInfosGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r AppsApiAppsAppInfosGetToManyRelatedRequest) Execute() (*AppInfosResponse, *http.Response, error) {
	return r.ApiService.AppsAppInfosGetToManyRelatedExecute(r)
}

/*
AppsAppInfosGetToManyRelated Method for AppsAppInfosGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsAppInfosGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsAppInfosGetToManyRelated(ctx context.Context, id string) AppsApiAppsAppInfosGetToManyRelatedRequest {
	return AppsApiAppsAppInfosGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppInfosResponse
func (a *AppsApiService) AppsAppInfosGetToManyRelatedExecute(r AppsApiAppsAppInfosGetToManyRelatedRequest) (*AppInfosResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppInfosResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsAppInfosGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/appInfos"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAgeRatingDeclarations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[ageRatingDeclarations]", r.fieldsAgeRatingDeclarations, "csv")
	}
	if r.fieldsAppInfos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appInfos]", r.fieldsAppInfos, "csv")
	}
	if r.fieldsAppInfoLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appInfoLocalizations]", r.fieldsAppInfoLocalizations, "csv")
	}
	if r.fieldsAppCategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCategories]", r.fieldsAppCategories, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.limitAppInfoLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appInfoLocalizations]", r.limitAppInfoLocalizations, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsAppPricePointsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	filterTerritory *[]string
	fieldsAppPricePoints *[]string
	fieldsApps *[]string
	fieldsTerritories *[]string
	limit *int32
	include *[]string
}

// filter by id(s) of related &#39;territory&#39;
func (r AppsApiAppsAppPricePointsGetToManyRelatedRequest) FilterTerritory(filterTerritory []string) AppsApiAppsAppPricePointsGetToManyRelatedRequest {
	r.filterTerritory = &filterTerritory
	return r
}

// the fields to include for returned resources of type appPricePoints
func (r AppsApiAppsAppPricePointsGetToManyRelatedRequest) FieldsAppPricePoints(fieldsAppPricePoints []string) AppsApiAppsAppPricePointsGetToManyRelatedRequest {
	r.fieldsAppPricePoints = &fieldsAppPricePoints
	return r
}

// the fields to include for returned resources of type apps
func (r AppsApiAppsAppPricePointsGetToManyRelatedRequest) FieldsApps(fieldsApps []string) AppsApiAppsAppPricePointsGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type territories
func (r AppsApiAppsAppPricePointsGetToManyRelatedRequest) FieldsTerritories(fieldsTerritories []string) AppsApiAppsAppPricePointsGetToManyRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// maximum resources per page
func (r AppsApiAppsAppPricePointsGetToManyRelatedRequest) Limit(limit int32) AppsApiAppsAppPricePointsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r AppsApiAppsAppPricePointsGetToManyRelatedRequest) Include(include []string) AppsApiAppsAppPricePointsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r AppsApiAppsAppPricePointsGetToManyRelatedRequest) Execute() (*AppPricePointsV3Response, *http.Response, error) {
	return r.ApiService.AppsAppPricePointsGetToManyRelatedExecute(r)
}

/*
AppsAppPricePointsGetToManyRelated Method for AppsAppPricePointsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsAppPricePointsGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsAppPricePointsGetToManyRelated(ctx context.Context, id string) AppsApiAppsAppPricePointsGetToManyRelatedRequest {
	return AppsApiAppsAppPricePointsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppPricePointsV3Response
func (a *AppsApiService) AppsAppPricePointsGetToManyRelatedExecute(r AppsApiAppsAppPricePointsGetToManyRelatedRequest) (*AppPricePointsV3Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppPricePointsV3Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsAppPricePointsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/appPricePoints"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterTerritory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[territory]", r.filterTerritory, "csv")
	}
	if r.fieldsAppPricePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPricePoints]", r.fieldsAppPricePoints, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsAppPriceScheduleGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	fieldsAppPrices *[]string
	fieldsAppPriceSchedules *[]string
	fieldsApps *[]string
	fieldsTerritories *[]string
	limitManualPrices *int32
	limitAutomaticPrices *int32
	include *[]string
}

// the fields to include for returned resources of type appPrices
func (r AppsApiAppsAppPriceScheduleGetToOneRelatedRequest) FieldsAppPrices(fieldsAppPrices []string) AppsApiAppsAppPriceScheduleGetToOneRelatedRequest {
	r.fieldsAppPrices = &fieldsAppPrices
	return r
}

// the fields to include for returned resources of type appPriceSchedules
func (r AppsApiAppsAppPriceScheduleGetToOneRelatedRequest) FieldsAppPriceSchedules(fieldsAppPriceSchedules []string) AppsApiAppsAppPriceScheduleGetToOneRelatedRequest {
	r.fieldsAppPriceSchedules = &fieldsAppPriceSchedules
	return r
}

// the fields to include for returned resources of type apps
func (r AppsApiAppsAppPriceScheduleGetToOneRelatedRequest) FieldsApps(fieldsApps []string) AppsApiAppsAppPriceScheduleGetToOneRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type territories
func (r AppsApiAppsAppPriceScheduleGetToOneRelatedRequest) FieldsTerritories(fieldsTerritories []string) AppsApiAppsAppPriceScheduleGetToOneRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// maximum number of related manualPrices returned (when they are included)
func (r AppsApiAppsAppPriceScheduleGetToOneRelatedRequest) LimitManualPrices(limitManualPrices int32) AppsApiAppsAppPriceScheduleGetToOneRelatedRequest {
	r.limitManualPrices = &limitManualPrices
	return r
}

// maximum number of related automaticPrices returned (when they are included)
func (r AppsApiAppsAppPriceScheduleGetToOneRelatedRequest) LimitAutomaticPrices(limitAutomaticPrices int32) AppsApiAppsAppPriceScheduleGetToOneRelatedRequest {
	r.limitAutomaticPrices = &limitAutomaticPrices
	return r
}

// comma-separated list of relationships to include
func (r AppsApiAppsAppPriceScheduleGetToOneRelatedRequest) Include(include []string) AppsApiAppsAppPriceScheduleGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r AppsApiAppsAppPriceScheduleGetToOneRelatedRequest) Execute() (*AppPriceScheduleResponse, *http.Response, error) {
	return r.ApiService.AppsAppPriceScheduleGetToOneRelatedExecute(r)
}

/*
AppsAppPriceScheduleGetToOneRelated Method for AppsAppPriceScheduleGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsAppPriceScheduleGetToOneRelatedRequest
*/
func (a *AppsApiService) AppsAppPriceScheduleGetToOneRelated(ctx context.Context, id string) AppsApiAppsAppPriceScheduleGetToOneRelatedRequest {
	return AppsApiAppsAppPriceScheduleGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppPriceScheduleResponse
func (a *AppsApiService) AppsAppPriceScheduleGetToOneRelatedExecute(r AppsApiAppsAppPriceScheduleGetToOneRelatedRequest) (*AppPriceScheduleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppPriceScheduleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsAppPriceScheduleGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/appPriceSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPrices]", r.fieldsAppPrices, "csv")
	}
	if r.fieldsAppPriceSchedules != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPriceSchedules]", r.fieldsAppPriceSchedules, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "csv")
	}
	if r.limitManualPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[manualPrices]", r.limitManualPrices, "")
	}
	if r.limitAutomaticPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[automaticPrices]", r.limitAutomaticPrices, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsAppStoreVersionsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	filterAppStoreState *[]string
	filterPlatform *[]string
	filterVersionString *[]string
	filterId *[]string
	fieldsAppStoreVersionExperiments *[]string
	fieldsAgeRatingDeclarations *[]string
	fieldsAppStoreVersionSubmissions *[]string
	fieldsAppStoreReviewDetails *[]string
	fieldsAppStoreVersions *[]string
	fieldsApps *[]string
	fieldsRoutingAppCoverages *[]string
	fieldsAppClipDefaultExperiences *[]string
	fieldsAppStoreVersionPhasedReleases *[]string
	fieldsBuilds *[]string
	fieldsAppStoreVersionLocalizations *[]string
	limit *int32
	limitAppStoreVersionLocalizations *int32
	limitAppStoreVersionExperiments *int32
	include *[]string
}

// filter by attribute &#39;appStoreState&#39;
func (r AppsApiAppsAppStoreVersionsGetToManyRelatedRequest) FilterAppStoreState(filterAppStoreState []string) AppsApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.filterAppStoreState = &filterAppStoreState
	return r
}

// filter by attribute &#39;platform&#39;
func (r AppsApiAppsAppStoreVersionsGetToManyRelatedRequest) FilterPlatform(filterPlatform []string) AppsApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.filterPlatform = &filterPlatform
	return r
}

// filter by attribute &#39;versionString&#39;
func (r AppsApiAppsAppStoreVersionsGetToManyRelatedRequest) FilterVersionString(filterVersionString []string) AppsApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.filterVersionString = &filterVersionString
	return r
}

// filter by id(s)
func (r AppsApiAppsAppStoreVersionsGetToManyRelatedRequest) FilterId(filterId []string) AppsApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.filterId = &filterId
	return r
}

// the fields to include for returned resources of type appStoreVersionExperiments
func (r AppsApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsAppStoreVersionExperiments(fieldsAppStoreVersionExperiments []string) AppsApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsAppStoreVersionExperiments = &fieldsAppStoreVersionExperiments
	return r
}

// the fields to include for returned resources of type ageRatingDeclarations
func (r AppsApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsAgeRatingDeclarations(fieldsAgeRatingDeclarations []string) AppsApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsAgeRatingDeclarations = &fieldsAgeRatingDeclarations
	return r
}

// the fields to include for returned resources of type appStoreVersionSubmissions
func (r AppsApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsAppStoreVersionSubmissions(fieldsAppStoreVersionSubmissions []string) AppsApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsAppStoreVersionSubmissions = &fieldsAppStoreVersionSubmissions
	return r
}

// the fields to include for returned resources of type appStoreReviewDetails
func (r AppsApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsAppStoreReviewDetails(fieldsAppStoreReviewDetails []string) AppsApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsAppStoreReviewDetails = &fieldsAppStoreReviewDetails
	return r
}

// the fields to include for returned resources of type appStoreVersions
func (r AppsApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsAppStoreVersions(fieldsAppStoreVersions []string) AppsApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsAppStoreVersions = &fieldsAppStoreVersions
	return r
}

// the fields to include for returned resources of type apps
func (r AppsApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsApps(fieldsApps []string) AppsApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type routingAppCoverages
func (r AppsApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsRoutingAppCoverages(fieldsRoutingAppCoverages []string) AppsApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsRoutingAppCoverages = &fieldsRoutingAppCoverages
	return r
}

// the fields to include for returned resources of type appClipDefaultExperiences
func (r AppsApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsAppClipDefaultExperiences(fieldsAppClipDefaultExperiences []string) AppsApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsAppClipDefaultExperiences = &fieldsAppClipDefaultExperiences
	return r
}

// the fields to include for returned resources of type appStoreVersionPhasedReleases
func (r AppsApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsAppStoreVersionPhasedReleases(fieldsAppStoreVersionPhasedReleases []string) AppsApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsAppStoreVersionPhasedReleases = &fieldsAppStoreVersionPhasedReleases
	return r
}

// the fields to include for returned resources of type builds
func (r AppsApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsBuilds(fieldsBuilds []string) AppsApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsBuilds = &fieldsBuilds
	return r
}

// the fields to include for returned resources of type appStoreVersionLocalizations
func (r AppsApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsAppStoreVersionLocalizations(fieldsAppStoreVersionLocalizations []string) AppsApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsAppStoreVersionLocalizations = &fieldsAppStoreVersionLocalizations
	return r
}

// maximum resources per page
func (r AppsApiAppsAppStoreVersionsGetToManyRelatedRequest) Limit(limit int32) AppsApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// maximum number of related appStoreVersionLocalizations returned (when they are included)
func (r AppsApiAppsAppStoreVersionsGetToManyRelatedRequest) LimitAppStoreVersionLocalizations(limitAppStoreVersionLocalizations int32) AppsApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.limitAppStoreVersionLocalizations = &limitAppStoreVersionLocalizations
	return r
}

// maximum number of related appStoreVersionExperiments returned (when they are included)
func (r AppsApiAppsAppStoreVersionsGetToManyRelatedRequest) LimitAppStoreVersionExperiments(limitAppStoreVersionExperiments int32) AppsApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.limitAppStoreVersionExperiments = &limitAppStoreVersionExperiments
	return r
}

// comma-separated list of relationships to include
func (r AppsApiAppsAppStoreVersionsGetToManyRelatedRequest) Include(include []string) AppsApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r AppsApiAppsAppStoreVersionsGetToManyRelatedRequest) Execute() (*AppStoreVersionsResponse, *http.Response, error) {
	return r.ApiService.AppsAppStoreVersionsGetToManyRelatedExecute(r)
}

/*
AppsAppStoreVersionsGetToManyRelated Method for AppsAppStoreVersionsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsAppStoreVersionsGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsAppStoreVersionsGetToManyRelated(ctx context.Context, id string) AppsApiAppsAppStoreVersionsGetToManyRelatedRequest {
	return AppsApiAppsAppStoreVersionsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppStoreVersionsResponse
func (a *AppsApiService) AppsAppStoreVersionsGetToManyRelatedExecute(r AppsApiAppsAppStoreVersionsGetToManyRelatedRequest) (*AppStoreVersionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppStoreVersionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsAppStoreVersionsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/appStoreVersions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterAppStoreState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[appStoreState]", r.filterAppStoreState, "csv")
	}
	if r.filterPlatform != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[platform]", r.filterPlatform, "csv")
	}
	if r.filterVersionString != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[versionString]", r.filterVersionString, "csv")
	}
	if r.filterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[id]", r.filterId, "csv")
	}
	if r.fieldsAppStoreVersionExperiments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersionExperiments]", r.fieldsAppStoreVersionExperiments, "csv")
	}
	if r.fieldsAgeRatingDeclarations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[ageRatingDeclarations]", r.fieldsAgeRatingDeclarations, "csv")
	}
	if r.fieldsAppStoreVersionSubmissions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersionSubmissions]", r.fieldsAppStoreVersionSubmissions, "csv")
	}
	if r.fieldsAppStoreReviewDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreReviewDetails]", r.fieldsAppStoreReviewDetails, "csv")
	}
	if r.fieldsAppStoreVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersions]", r.fieldsAppStoreVersions, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.fieldsRoutingAppCoverages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[routingAppCoverages]", r.fieldsRoutingAppCoverages, "csv")
	}
	if r.fieldsAppClipDefaultExperiences != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appClipDefaultExperiences]", r.fieldsAppClipDefaultExperiences, "csv")
	}
	if r.fieldsAppStoreVersionPhasedReleases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersionPhasedReleases]", r.fieldsAppStoreVersionPhasedReleases, "csv")
	}
	if r.fieldsBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[builds]", r.fieldsBuilds, "csv")
	}
	if r.fieldsAppStoreVersionLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersionLocalizations]", r.fieldsAppStoreVersionLocalizations, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.limitAppStoreVersionLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appStoreVersionLocalizations]", r.limitAppStoreVersionLocalizations, "")
	}
	if r.limitAppStoreVersionExperiments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appStoreVersionExperiments]", r.limitAppStoreVersionExperiments, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsAvailableTerritoriesGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	fieldsTerritories *[]string
	limit *int32
}

// the fields to include for returned resources of type territories
func (r AppsApiAppsAvailableTerritoriesGetToManyRelatedRequest) FieldsTerritories(fieldsTerritories []string) AppsApiAppsAvailableTerritoriesGetToManyRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// maximum resources per page
func (r AppsApiAppsAvailableTerritoriesGetToManyRelatedRequest) Limit(limit int32) AppsApiAppsAvailableTerritoriesGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

func (r AppsApiAppsAvailableTerritoriesGetToManyRelatedRequest) Execute() (*TerritoriesResponse, *http.Response, error) {
	return r.ApiService.AppsAvailableTerritoriesGetToManyRelatedExecute(r)
}

/*
AppsAvailableTerritoriesGetToManyRelated Method for AppsAvailableTerritoriesGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsAvailableTerritoriesGetToManyRelatedRequest

Deprecated
*/
func (a *AppsApiService) AppsAvailableTerritoriesGetToManyRelated(ctx context.Context, id string) AppsApiAppsAvailableTerritoriesGetToManyRelatedRequest {
	return AppsApiAppsAvailableTerritoriesGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return TerritoriesResponse
// Deprecated
func (a *AppsApiService) AppsAvailableTerritoriesGetToManyRelatedExecute(r AppsApiAppsAvailableTerritoriesGetToManyRelatedRequest) (*TerritoriesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TerritoriesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsAvailableTerritoriesGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/availableTerritories"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsBetaAppLocalizationsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	fieldsBetaAppLocalizations *[]string
	limit *int32
}

// the fields to include for returned resources of type betaAppLocalizations
func (r AppsApiAppsBetaAppLocalizationsGetToManyRelatedRequest) FieldsBetaAppLocalizations(fieldsBetaAppLocalizations []string) AppsApiAppsBetaAppLocalizationsGetToManyRelatedRequest {
	r.fieldsBetaAppLocalizations = &fieldsBetaAppLocalizations
	return r
}

// maximum resources per page
func (r AppsApiAppsBetaAppLocalizationsGetToManyRelatedRequest) Limit(limit int32) AppsApiAppsBetaAppLocalizationsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

func (r AppsApiAppsBetaAppLocalizationsGetToManyRelatedRequest) Execute() (*BetaAppLocalizationsResponse, *http.Response, error) {
	return r.ApiService.AppsBetaAppLocalizationsGetToManyRelatedExecute(r)
}

/*
AppsBetaAppLocalizationsGetToManyRelated Method for AppsBetaAppLocalizationsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsBetaAppLocalizationsGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsBetaAppLocalizationsGetToManyRelated(ctx context.Context, id string) AppsApiAppsBetaAppLocalizationsGetToManyRelatedRequest {
	return AppsApiAppsBetaAppLocalizationsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return BetaAppLocalizationsResponse
func (a *AppsApiService) AppsBetaAppLocalizationsGetToManyRelatedExecute(r AppsApiAppsBetaAppLocalizationsGetToManyRelatedRequest) (*BetaAppLocalizationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BetaAppLocalizationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsBetaAppLocalizationsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/betaAppLocalizations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsBetaAppLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaAppLocalizations]", r.fieldsBetaAppLocalizations, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsBetaAppReviewDetailGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	fieldsBetaAppReviewDetails *[]string
}

// the fields to include for returned resources of type betaAppReviewDetails
func (r AppsApiAppsBetaAppReviewDetailGetToOneRelatedRequest) FieldsBetaAppReviewDetails(fieldsBetaAppReviewDetails []string) AppsApiAppsBetaAppReviewDetailGetToOneRelatedRequest {
	r.fieldsBetaAppReviewDetails = &fieldsBetaAppReviewDetails
	return r
}

func (r AppsApiAppsBetaAppReviewDetailGetToOneRelatedRequest) Execute() (*BetaAppReviewDetailResponse, *http.Response, error) {
	return r.ApiService.AppsBetaAppReviewDetailGetToOneRelatedExecute(r)
}

/*
AppsBetaAppReviewDetailGetToOneRelated Method for AppsBetaAppReviewDetailGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsBetaAppReviewDetailGetToOneRelatedRequest
*/
func (a *AppsApiService) AppsBetaAppReviewDetailGetToOneRelated(ctx context.Context, id string) AppsApiAppsBetaAppReviewDetailGetToOneRelatedRequest {
	return AppsApiAppsBetaAppReviewDetailGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return BetaAppReviewDetailResponse
func (a *AppsApiService) AppsBetaAppReviewDetailGetToOneRelatedExecute(r AppsApiAppsBetaAppReviewDetailGetToOneRelatedRequest) (*BetaAppReviewDetailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BetaAppReviewDetailResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsBetaAppReviewDetailGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/betaAppReviewDetail"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsBetaAppReviewDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaAppReviewDetails]", r.fieldsBetaAppReviewDetails, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsBetaGroupsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	fieldsBetaGroups *[]string
	limit *int32
}

// the fields to include for returned resources of type betaGroups
func (r AppsApiAppsBetaGroupsGetToManyRelatedRequest) FieldsBetaGroups(fieldsBetaGroups []string) AppsApiAppsBetaGroupsGetToManyRelatedRequest {
	r.fieldsBetaGroups = &fieldsBetaGroups
	return r
}

// maximum resources per page
func (r AppsApiAppsBetaGroupsGetToManyRelatedRequest) Limit(limit int32) AppsApiAppsBetaGroupsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

func (r AppsApiAppsBetaGroupsGetToManyRelatedRequest) Execute() (*BetaGroupsResponse, *http.Response, error) {
	return r.ApiService.AppsBetaGroupsGetToManyRelatedExecute(r)
}

/*
AppsBetaGroupsGetToManyRelated Method for AppsBetaGroupsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsBetaGroupsGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsBetaGroupsGetToManyRelated(ctx context.Context, id string) AppsApiAppsBetaGroupsGetToManyRelatedRequest {
	return AppsApiAppsBetaGroupsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return BetaGroupsResponse
func (a *AppsApiService) AppsBetaGroupsGetToManyRelatedExecute(r AppsApiAppsBetaGroupsGetToManyRelatedRequest) (*BetaGroupsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BetaGroupsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsBetaGroupsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/betaGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsBetaGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaGroups]", r.fieldsBetaGroups, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsBetaLicenseAgreementGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	fieldsBetaLicenseAgreements *[]string
}

// the fields to include for returned resources of type betaLicenseAgreements
func (r AppsApiAppsBetaLicenseAgreementGetToOneRelatedRequest) FieldsBetaLicenseAgreements(fieldsBetaLicenseAgreements []string) AppsApiAppsBetaLicenseAgreementGetToOneRelatedRequest {
	r.fieldsBetaLicenseAgreements = &fieldsBetaLicenseAgreements
	return r
}

func (r AppsApiAppsBetaLicenseAgreementGetToOneRelatedRequest) Execute() (*BetaLicenseAgreementResponse, *http.Response, error) {
	return r.ApiService.AppsBetaLicenseAgreementGetToOneRelatedExecute(r)
}

/*
AppsBetaLicenseAgreementGetToOneRelated Method for AppsBetaLicenseAgreementGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsBetaLicenseAgreementGetToOneRelatedRequest
*/
func (a *AppsApiService) AppsBetaLicenseAgreementGetToOneRelated(ctx context.Context, id string) AppsApiAppsBetaLicenseAgreementGetToOneRelatedRequest {
	return AppsApiAppsBetaLicenseAgreementGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return BetaLicenseAgreementResponse
func (a *AppsApiService) AppsBetaLicenseAgreementGetToOneRelatedExecute(r AppsApiAppsBetaLicenseAgreementGetToOneRelatedRequest) (*BetaLicenseAgreementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BetaLicenseAgreementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsBetaLicenseAgreementGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/betaLicenseAgreement"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsBetaLicenseAgreements != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaLicenseAgreements]", r.fieldsBetaLicenseAgreements, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsBetaTestersDeleteToManyRelationshipRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	appBetaTestersLinkagesRequest *AppBetaTestersLinkagesRequest
}

// List of related linkages
func (r AppsApiAppsBetaTestersDeleteToManyRelationshipRequest) AppBetaTestersLinkagesRequest(appBetaTestersLinkagesRequest AppBetaTestersLinkagesRequest) AppsApiAppsBetaTestersDeleteToManyRelationshipRequest {
	r.appBetaTestersLinkagesRequest = &appBetaTestersLinkagesRequest
	return r
}

func (r AppsApiAppsBetaTestersDeleteToManyRelationshipRequest) Execute() (*http.Response, error) {
	return r.ApiService.AppsBetaTestersDeleteToManyRelationshipExecute(r)
}

/*
AppsBetaTestersDeleteToManyRelationship Method for AppsBetaTestersDeleteToManyRelationship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsBetaTestersDeleteToManyRelationshipRequest
*/
func (a *AppsApiService) AppsBetaTestersDeleteToManyRelationship(ctx context.Context, id string) AppsApiAppsBetaTestersDeleteToManyRelationshipRequest {
	return AppsApiAppsBetaTestersDeleteToManyRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *AppsApiService) AppsBetaTestersDeleteToManyRelationshipExecute(r AppsApiAppsBetaTestersDeleteToManyRelationshipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsBetaTestersDeleteToManyRelationship")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/relationships/betaTesters"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appBetaTestersLinkagesRequest == nil {
		return nil, reportError("appBetaTestersLinkagesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appBetaTestersLinkagesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AppsApiAppsBuildsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	fieldsBuilds *[]string
	limit *int32
}

// the fields to include for returned resources of type builds
func (r AppsApiAppsBuildsGetToManyRelatedRequest) FieldsBuilds(fieldsBuilds []string) AppsApiAppsBuildsGetToManyRelatedRequest {
	r.fieldsBuilds = &fieldsBuilds
	return r
}

// maximum resources per page
func (r AppsApiAppsBuildsGetToManyRelatedRequest) Limit(limit int32) AppsApiAppsBuildsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

func (r AppsApiAppsBuildsGetToManyRelatedRequest) Execute() (*BuildsResponse, *http.Response, error) {
	return r.ApiService.AppsBuildsGetToManyRelatedExecute(r)
}

/*
AppsBuildsGetToManyRelated Method for AppsBuildsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsBuildsGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsBuildsGetToManyRelated(ctx context.Context, id string) AppsApiAppsBuildsGetToManyRelatedRequest {
	return AppsApiAppsBuildsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return BuildsResponse
func (a *AppsApiService) AppsBuildsGetToManyRelatedExecute(r AppsApiAppsBuildsGetToManyRelatedRequest) (*BuildsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BuildsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsBuildsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/builds"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[builds]", r.fieldsBuilds, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsCiProductGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	fieldsCiProducts *[]string
	fieldsApps *[]string
	fieldsScmRepositories *[]string
	fieldsBundleIds *[]string
	limitPrimaryRepositories *int32
	include *[]string
}

// the fields to include for returned resources of type ciProducts
func (r AppsApiAppsCiProductGetToOneRelatedRequest) FieldsCiProducts(fieldsCiProducts []string) AppsApiAppsCiProductGetToOneRelatedRequest {
	r.fieldsCiProducts = &fieldsCiProducts
	return r
}

// the fields to include for returned resources of type apps
func (r AppsApiAppsCiProductGetToOneRelatedRequest) FieldsApps(fieldsApps []string) AppsApiAppsCiProductGetToOneRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type scmRepositories
func (r AppsApiAppsCiProductGetToOneRelatedRequest) FieldsScmRepositories(fieldsScmRepositories []string) AppsApiAppsCiProductGetToOneRelatedRequest {
	r.fieldsScmRepositories = &fieldsScmRepositories
	return r
}

// the fields to include for returned resources of type bundleIds
func (r AppsApiAppsCiProductGetToOneRelatedRequest) FieldsBundleIds(fieldsBundleIds []string) AppsApiAppsCiProductGetToOneRelatedRequest {
	r.fieldsBundleIds = &fieldsBundleIds
	return r
}

// maximum number of related primaryRepositories returned (when they are included)
func (r AppsApiAppsCiProductGetToOneRelatedRequest) LimitPrimaryRepositories(limitPrimaryRepositories int32) AppsApiAppsCiProductGetToOneRelatedRequest {
	r.limitPrimaryRepositories = &limitPrimaryRepositories
	return r
}

// comma-separated list of relationships to include
func (r AppsApiAppsCiProductGetToOneRelatedRequest) Include(include []string) AppsApiAppsCiProductGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r AppsApiAppsCiProductGetToOneRelatedRequest) Execute() (*CiProductResponse, *http.Response, error) {
	return r.ApiService.AppsCiProductGetToOneRelatedExecute(r)
}

/*
AppsCiProductGetToOneRelated Method for AppsCiProductGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsCiProductGetToOneRelatedRequest
*/
func (a *AppsApiService) AppsCiProductGetToOneRelated(ctx context.Context, id string) AppsApiAppsCiProductGetToOneRelatedRequest {
	return AppsApiAppsCiProductGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CiProductResponse
func (a *AppsApiService) AppsCiProductGetToOneRelatedExecute(r AppsApiAppsCiProductGetToOneRelatedRequest) (*CiProductResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CiProductResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsCiProductGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/ciProduct"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsCiProducts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[ciProducts]", r.fieldsCiProducts, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.fieldsScmRepositories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[scmRepositories]", r.fieldsScmRepositories, "csv")
	}
	if r.fieldsBundleIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[bundleIds]", r.fieldsBundleIds, "csv")
	}
	if r.limitPrimaryRepositories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[primaryRepositories]", r.limitPrimaryRepositories, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsCustomerReviewsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	filterRating *[]string
	filterTerritory *[]string
	existsPublishedResponse *bool
	sort *[]string
	fieldsCustomerReviews *[]string
	fieldsCustomerReviewResponses *[]string
	limit *int32
	include *[]string
}

// filter by attribute &#39;rating&#39;
func (r AppsApiAppsCustomerReviewsGetToManyRelatedRequest) FilterRating(filterRating []string) AppsApiAppsCustomerReviewsGetToManyRelatedRequest {
	r.filterRating = &filterRating
	return r
}

// filter by attribute &#39;territory&#39;
func (r AppsApiAppsCustomerReviewsGetToManyRelatedRequest) FilterTerritory(filterTerritory []string) AppsApiAppsCustomerReviewsGetToManyRelatedRequest {
	r.filterTerritory = &filterTerritory
	return r
}

// filter by publishedResponse
func (r AppsApiAppsCustomerReviewsGetToManyRelatedRequest) ExistsPublishedResponse(existsPublishedResponse bool) AppsApiAppsCustomerReviewsGetToManyRelatedRequest {
	r.existsPublishedResponse = &existsPublishedResponse
	return r
}

// comma-separated list of sort expressions; resources will be sorted as specified
func (r AppsApiAppsCustomerReviewsGetToManyRelatedRequest) Sort(sort []string) AppsApiAppsCustomerReviewsGetToManyRelatedRequest {
	r.sort = &sort
	return r
}

// the fields to include for returned resources of type customerReviews
func (r AppsApiAppsCustomerReviewsGetToManyRelatedRequest) FieldsCustomerReviews(fieldsCustomerReviews []string) AppsApiAppsCustomerReviewsGetToManyRelatedRequest {
	r.fieldsCustomerReviews = &fieldsCustomerReviews
	return r
}

// the fields to include for returned resources of type customerReviewResponses
func (r AppsApiAppsCustomerReviewsGetToManyRelatedRequest) FieldsCustomerReviewResponses(fieldsCustomerReviewResponses []string) AppsApiAppsCustomerReviewsGetToManyRelatedRequest {
	r.fieldsCustomerReviewResponses = &fieldsCustomerReviewResponses
	return r
}

// maximum resources per page
func (r AppsApiAppsCustomerReviewsGetToManyRelatedRequest) Limit(limit int32) AppsApiAppsCustomerReviewsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r AppsApiAppsCustomerReviewsGetToManyRelatedRequest) Include(include []string) AppsApiAppsCustomerReviewsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r AppsApiAppsCustomerReviewsGetToManyRelatedRequest) Execute() (*CustomerReviewsResponse, *http.Response, error) {
	return r.ApiService.AppsCustomerReviewsGetToManyRelatedExecute(r)
}

/*
AppsCustomerReviewsGetToManyRelated Method for AppsCustomerReviewsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsCustomerReviewsGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsCustomerReviewsGetToManyRelated(ctx context.Context, id string) AppsApiAppsCustomerReviewsGetToManyRelatedRequest {
	return AppsApiAppsCustomerReviewsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CustomerReviewsResponse
func (a *AppsApiService) AppsCustomerReviewsGetToManyRelatedExecute(r AppsApiAppsCustomerReviewsGetToManyRelatedRequest) (*CustomerReviewsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerReviewsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsCustomerReviewsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/customerReviews"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[rating]", r.filterRating, "csv")
	}
	if r.filterTerritory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[territory]", r.filterTerritory, "csv")
	}
	if r.existsPublishedResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exists[publishedResponse]", r.existsPublishedResponse, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "csv")
	}
	if r.fieldsCustomerReviews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[customerReviews]", r.fieldsCustomerReviews, "csv")
	}
	if r.fieldsCustomerReviewResponses != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[customerReviewResponses]", r.fieldsCustomerReviewResponses, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsEndUserLicenseAgreementGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	fieldsEndUserLicenseAgreements *[]string
}

// the fields to include for returned resources of type endUserLicenseAgreements
func (r AppsApiAppsEndUserLicenseAgreementGetToOneRelatedRequest) FieldsEndUserLicenseAgreements(fieldsEndUserLicenseAgreements []string) AppsApiAppsEndUserLicenseAgreementGetToOneRelatedRequest {
	r.fieldsEndUserLicenseAgreements = &fieldsEndUserLicenseAgreements
	return r
}

func (r AppsApiAppsEndUserLicenseAgreementGetToOneRelatedRequest) Execute() (*EndUserLicenseAgreementResponse, *http.Response, error) {
	return r.ApiService.AppsEndUserLicenseAgreementGetToOneRelatedExecute(r)
}

/*
AppsEndUserLicenseAgreementGetToOneRelated Method for AppsEndUserLicenseAgreementGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsEndUserLicenseAgreementGetToOneRelatedRequest
*/
func (a *AppsApiService) AppsEndUserLicenseAgreementGetToOneRelated(ctx context.Context, id string) AppsApiAppsEndUserLicenseAgreementGetToOneRelatedRequest {
	return AppsApiAppsEndUserLicenseAgreementGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return EndUserLicenseAgreementResponse
func (a *AppsApiService) AppsEndUserLicenseAgreementGetToOneRelatedExecute(r AppsApiAppsEndUserLicenseAgreementGetToOneRelatedRequest) (*EndUserLicenseAgreementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EndUserLicenseAgreementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsEndUserLicenseAgreementGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/endUserLicenseAgreement"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsEndUserLicenseAgreements != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[endUserLicenseAgreements]", r.fieldsEndUserLicenseAgreements, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	filterPlatform *[]string
	filterVersionString *[]string
	filterId *[]string
	sort *[]string
	fieldsGameCenterEnabledVersions *[]string
	fieldsApps *[]string
	limit *int32
	limitCompatibleVersions *int32
	include *[]string
}

// filter by attribute &#39;platform&#39;
func (r AppsApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) FilterPlatform(filterPlatform []string) AppsApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.filterPlatform = &filterPlatform
	return r
}

// filter by attribute &#39;versionString&#39;
func (r AppsApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) FilterVersionString(filterVersionString []string) AppsApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.filterVersionString = &filterVersionString
	return r
}

// filter by id(s)
func (r AppsApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) FilterId(filterId []string) AppsApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.filterId = &filterId
	return r
}

// comma-separated list of sort expressions; resources will be sorted as specified
func (r AppsApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) Sort(sort []string) AppsApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.sort = &sort
	return r
}

// the fields to include for returned resources of type gameCenterEnabledVersions
func (r AppsApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) FieldsGameCenterEnabledVersions(fieldsGameCenterEnabledVersions []string) AppsApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.fieldsGameCenterEnabledVersions = &fieldsGameCenterEnabledVersions
	return r
}

// the fields to include for returned resources of type apps
func (r AppsApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) FieldsApps(fieldsApps []string) AppsApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// maximum resources per page
func (r AppsApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) Limit(limit int32) AppsApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// maximum number of related compatibleVersions returned (when they are included)
func (r AppsApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) LimitCompatibleVersions(limitCompatibleVersions int32) AppsApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.limitCompatibleVersions = &limitCompatibleVersions
	return r
}

// comma-separated list of relationships to include
func (r AppsApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) Include(include []string) AppsApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r AppsApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) Execute() (*GameCenterEnabledVersionsResponse, *http.Response, error) {
	return r.ApiService.AppsGameCenterEnabledVersionsGetToManyRelatedExecute(r)
}

/*
AppsGameCenterEnabledVersionsGetToManyRelated Method for AppsGameCenterEnabledVersionsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsGameCenterEnabledVersionsGetToManyRelated(ctx context.Context, id string) AppsApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	return AppsApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GameCenterEnabledVersionsResponse
func (a *AppsApiService) AppsGameCenterEnabledVersionsGetToManyRelatedExecute(r AppsApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) (*GameCenterEnabledVersionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GameCenterEnabledVersionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsGameCenterEnabledVersionsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/gameCenterEnabledVersions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPlatform != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[platform]", r.filterPlatform, "csv")
	}
	if r.filterVersionString != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[versionString]", r.filterVersionString, "csv")
	}
	if r.filterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[id]", r.filterId, "csv")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "csv")
	}
	if r.fieldsGameCenterEnabledVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterEnabledVersions]", r.fieldsGameCenterEnabledVersions, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.limitCompatibleVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[compatibleVersions]", r.limitCompatibleVersions, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsGetCollectionRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	filterAppStoreVersionsAppStoreState *[]string
	filterAppStoreVersionsPlatform *[]string
	filterBundleId *[]string
	filterName *[]string
	filterSku *[]string
	filterAppStoreVersions *[]string
	filterId *[]string
	existsGameCenterEnabledVersions *bool
	sort *[]string
	fieldsApps *[]string
	limit *int32
	include *[]string
	fieldsBetaAppReviewDetails *[]string
	fieldsAppPriceSchedules *[]string
	fieldsCiProducts *[]string
	fieldsReviewSubmissions *[]string
	fieldsBetaGroups *[]string
	fieldsPromotedPurchases *[]string
	fieldsAppAvailabilities *[]string
	fieldsCustomerReviews *[]string
	fieldsAppEvents *[]string
	fieldsBuilds *[]string
	fieldsBetaLicenseAgreements *[]string
	fieldsAppClips *[]string
	fieldsAppInfos *[]string
	fieldsBetaAppLocalizations *[]string
	fieldsAppPricePoints *[]string
	fieldsAppPricePoints2 *[]string
	fieldsInAppPurchases *[]string
	fieldsPreReleaseVersions *[]string
	fieldsInAppPurchases2 *[]string
	fieldsSubscriptionGroups *[]string
	fieldsAppPrices *[]string
	fieldsAppPreOrders *[]string
	fieldsGameCenterEnabledVersions *[]string
	fieldsSubscriptionGracePeriods *[]string
	fieldsEndUserLicenseAgreements *[]string
	fieldsAppStoreVersions *[]string
	fieldsAppCustomProductPages *[]string
	fieldsTerritories *[]string
	fieldsPerfPowerMetrics *[]string
	limitAppClips *int32
	limitAppCustomProductPages *int32
	limitAppEvents *int32
	limitAppInfos *int32
	limitAppStoreVersions *int32
	limitAvailableTerritories *int32
	limitBetaAppLocalizations *int32
	limitBetaGroups *int32
	limitBuilds *int32
	limitGameCenterEnabledVersions *int32
	limitInAppPurchases *int32
	limitInAppPurchasesV2 *int32
	limitPreReleaseVersions *int32
	limitPrices *int32
	limitPromotedPurchases *int32
	limitReviewSubmissions *int32
	limitSubscriptionGroups *int32
}

// filter by attribute &#39;appStoreVersions.appStoreState&#39;
func (r AppsApiAppsGetCollectionRequest) FilterAppStoreVersionsAppStoreState(filterAppStoreVersionsAppStoreState []string) AppsApiAppsGetCollectionRequest {
	r.filterAppStoreVersionsAppStoreState = &filterAppStoreVersionsAppStoreState
	return r
}

// filter by attribute &#39;appStoreVersions.platform&#39;
func (r AppsApiAppsGetCollectionRequest) FilterAppStoreVersionsPlatform(filterAppStoreVersionsPlatform []string) AppsApiAppsGetCollectionRequest {
	r.filterAppStoreVersionsPlatform = &filterAppStoreVersionsPlatform
	return r
}

// filter by attribute &#39;bundleId&#39;
func (r AppsApiAppsGetCollectionRequest) FilterBundleId(filterBundleId []string) AppsApiAppsGetCollectionRequest {
	r.filterBundleId = &filterBundleId
	return r
}

// filter by attribute &#39;name&#39;
func (r AppsApiAppsGetCollectionRequest) FilterName(filterName []string) AppsApiAppsGetCollectionRequest {
	r.filterName = &filterName
	return r
}

// filter by attribute &#39;sku&#39;
func (r AppsApiAppsGetCollectionRequest) FilterSku(filterSku []string) AppsApiAppsGetCollectionRequest {
	r.filterSku = &filterSku
	return r
}

// filter by id(s) of related &#39;appStoreVersions&#39;
func (r AppsApiAppsGetCollectionRequest) FilterAppStoreVersions(filterAppStoreVersions []string) AppsApiAppsGetCollectionRequest {
	r.filterAppStoreVersions = &filterAppStoreVersions
	return r
}

// filter by id(s)
func (r AppsApiAppsGetCollectionRequest) FilterId(filterId []string) AppsApiAppsGetCollectionRequest {
	r.filterId = &filterId
	return r
}

// filter by existence or non-existence of related &#39;gameCenterEnabledVersions&#39;
func (r AppsApiAppsGetCollectionRequest) ExistsGameCenterEnabledVersions(existsGameCenterEnabledVersions bool) AppsApiAppsGetCollectionRequest {
	r.existsGameCenterEnabledVersions = &existsGameCenterEnabledVersions
	return r
}

// comma-separated list of sort expressions; resources will be sorted as specified
func (r AppsApiAppsGetCollectionRequest) Sort(sort []string) AppsApiAppsGetCollectionRequest {
	r.sort = &sort
	return r
}

// the fields to include for returned resources of type apps
func (r AppsApiAppsGetCollectionRequest) FieldsApps(fieldsApps []string) AppsApiAppsGetCollectionRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// maximum resources per page
func (r AppsApiAppsGetCollectionRequest) Limit(limit int32) AppsApiAppsGetCollectionRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r AppsApiAppsGetCollectionRequest) Include(include []string) AppsApiAppsGetCollectionRequest {
	r.include = &include
	return r
}

// the fields to include for returned resources of type betaAppReviewDetails
func (r AppsApiAppsGetCollectionRequest) FieldsBetaAppReviewDetails(fieldsBetaAppReviewDetails []string) AppsApiAppsGetCollectionRequest {
	r.fieldsBetaAppReviewDetails = &fieldsBetaAppReviewDetails
	return r
}

// the fields to include for returned resources of type appPriceSchedules
func (r AppsApiAppsGetCollectionRequest) FieldsAppPriceSchedules(fieldsAppPriceSchedules []string) AppsApiAppsGetCollectionRequest {
	r.fieldsAppPriceSchedules = &fieldsAppPriceSchedules
	return r
}

// the fields to include for returned resources of type ciProducts
func (r AppsApiAppsGetCollectionRequest) FieldsCiProducts(fieldsCiProducts []string) AppsApiAppsGetCollectionRequest {
	r.fieldsCiProducts = &fieldsCiProducts
	return r
}

// the fields to include for returned resources of type reviewSubmissions
func (r AppsApiAppsGetCollectionRequest) FieldsReviewSubmissions(fieldsReviewSubmissions []string) AppsApiAppsGetCollectionRequest {
	r.fieldsReviewSubmissions = &fieldsReviewSubmissions
	return r
}

// the fields to include for returned resources of type betaGroups
func (r AppsApiAppsGetCollectionRequest) FieldsBetaGroups(fieldsBetaGroups []string) AppsApiAppsGetCollectionRequest {
	r.fieldsBetaGroups = &fieldsBetaGroups
	return r
}

// the fields to include for returned resources of type promotedPurchases
func (r AppsApiAppsGetCollectionRequest) FieldsPromotedPurchases(fieldsPromotedPurchases []string) AppsApiAppsGetCollectionRequest {
	r.fieldsPromotedPurchases = &fieldsPromotedPurchases
	return r
}

// the fields to include for returned resources of type appAvailabilities
func (r AppsApiAppsGetCollectionRequest) FieldsAppAvailabilities(fieldsAppAvailabilities []string) AppsApiAppsGetCollectionRequest {
	r.fieldsAppAvailabilities = &fieldsAppAvailabilities
	return r
}

// the fields to include for returned resources of type customerReviews
func (r AppsApiAppsGetCollectionRequest) FieldsCustomerReviews(fieldsCustomerReviews []string) AppsApiAppsGetCollectionRequest {
	r.fieldsCustomerReviews = &fieldsCustomerReviews
	return r
}

// the fields to include for returned resources of type appEvents
func (r AppsApiAppsGetCollectionRequest) FieldsAppEvents(fieldsAppEvents []string) AppsApiAppsGetCollectionRequest {
	r.fieldsAppEvents = &fieldsAppEvents
	return r
}

// the fields to include for returned resources of type builds
func (r AppsApiAppsGetCollectionRequest) FieldsBuilds(fieldsBuilds []string) AppsApiAppsGetCollectionRequest {
	r.fieldsBuilds = &fieldsBuilds
	return r
}

// the fields to include for returned resources of type betaLicenseAgreements
func (r AppsApiAppsGetCollectionRequest) FieldsBetaLicenseAgreements(fieldsBetaLicenseAgreements []string) AppsApiAppsGetCollectionRequest {
	r.fieldsBetaLicenseAgreements = &fieldsBetaLicenseAgreements
	return r
}

// the fields to include for returned resources of type appClips
func (r AppsApiAppsGetCollectionRequest) FieldsAppClips(fieldsAppClips []string) AppsApiAppsGetCollectionRequest {
	r.fieldsAppClips = &fieldsAppClips
	return r
}

// the fields to include for returned resources of type appInfos
func (r AppsApiAppsGetCollectionRequest) FieldsAppInfos(fieldsAppInfos []string) AppsApiAppsGetCollectionRequest {
	r.fieldsAppInfos = &fieldsAppInfos
	return r
}

// the fields to include for returned resources of type betaAppLocalizations
func (r AppsApiAppsGetCollectionRequest) FieldsBetaAppLocalizations(fieldsBetaAppLocalizations []string) AppsApiAppsGetCollectionRequest {
	r.fieldsBetaAppLocalizations = &fieldsBetaAppLocalizations
	return r
}

// the fields to include for returned resources of type appPricePoints
// Deprecated
func (r AppsApiAppsGetCollectionRequest) FieldsAppPricePoints(fieldsAppPricePoints []string) AppsApiAppsGetCollectionRequest {
	r.fieldsAppPricePoints = &fieldsAppPricePoints
	return r
}

// the fields to include for returned resources of type appPricePoints
func (r AppsApiAppsGetCollectionRequest) FieldsAppPricePoints2(fieldsAppPricePoints2 []string) AppsApiAppsGetCollectionRequest {
	r.fieldsAppPricePoints2 = &fieldsAppPricePoints2
	return r
}

// the fields to include for returned resources of type inAppPurchases
// Deprecated
func (r AppsApiAppsGetCollectionRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) AppsApiAppsGetCollectionRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// the fields to include for returned resources of type preReleaseVersions
func (r AppsApiAppsGetCollectionRequest) FieldsPreReleaseVersions(fieldsPreReleaseVersions []string) AppsApiAppsGetCollectionRequest {
	r.fieldsPreReleaseVersions = &fieldsPreReleaseVersions
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r AppsApiAppsGetCollectionRequest) FieldsInAppPurchases2(fieldsInAppPurchases2 []string) AppsApiAppsGetCollectionRequest {
	r.fieldsInAppPurchases2 = &fieldsInAppPurchases2
	return r
}

// the fields to include for returned resources of type subscriptionGroups
func (r AppsApiAppsGetCollectionRequest) FieldsSubscriptionGroups(fieldsSubscriptionGroups []string) AppsApiAppsGetCollectionRequest {
	r.fieldsSubscriptionGroups = &fieldsSubscriptionGroups
	return r
}

// the fields to include for returned resources of type appPrices
// Deprecated
func (r AppsApiAppsGetCollectionRequest) FieldsAppPrices(fieldsAppPrices []string) AppsApiAppsGetCollectionRequest {
	r.fieldsAppPrices = &fieldsAppPrices
	return r
}

// the fields to include for returned resources of type appPreOrders
func (r AppsApiAppsGetCollectionRequest) FieldsAppPreOrders(fieldsAppPreOrders []string) AppsApiAppsGetCollectionRequest {
	r.fieldsAppPreOrders = &fieldsAppPreOrders
	return r
}

// the fields to include for returned resources of type gameCenterEnabledVersions
func (r AppsApiAppsGetCollectionRequest) FieldsGameCenterEnabledVersions(fieldsGameCenterEnabledVersions []string) AppsApiAppsGetCollectionRequest {
	r.fieldsGameCenterEnabledVersions = &fieldsGameCenterEnabledVersions
	return r
}

// the fields to include for returned resources of type subscriptionGracePeriods
func (r AppsApiAppsGetCollectionRequest) FieldsSubscriptionGracePeriods(fieldsSubscriptionGracePeriods []string) AppsApiAppsGetCollectionRequest {
	r.fieldsSubscriptionGracePeriods = &fieldsSubscriptionGracePeriods
	return r
}

// the fields to include for returned resources of type endUserLicenseAgreements
func (r AppsApiAppsGetCollectionRequest) FieldsEndUserLicenseAgreements(fieldsEndUserLicenseAgreements []string) AppsApiAppsGetCollectionRequest {
	r.fieldsEndUserLicenseAgreements = &fieldsEndUserLicenseAgreements
	return r
}

// the fields to include for returned resources of type appStoreVersions
func (r AppsApiAppsGetCollectionRequest) FieldsAppStoreVersions(fieldsAppStoreVersions []string) AppsApiAppsGetCollectionRequest {
	r.fieldsAppStoreVersions = &fieldsAppStoreVersions
	return r
}

// the fields to include for returned resources of type appCustomProductPages
func (r AppsApiAppsGetCollectionRequest) FieldsAppCustomProductPages(fieldsAppCustomProductPages []string) AppsApiAppsGetCollectionRequest {
	r.fieldsAppCustomProductPages = &fieldsAppCustomProductPages
	return r
}

// the fields to include for returned resources of type territories
// Deprecated
func (r AppsApiAppsGetCollectionRequest) FieldsTerritories(fieldsTerritories []string) AppsApiAppsGetCollectionRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// the fields to include for returned resources of type perfPowerMetrics
func (r AppsApiAppsGetCollectionRequest) FieldsPerfPowerMetrics(fieldsPerfPowerMetrics []string) AppsApiAppsGetCollectionRequest {
	r.fieldsPerfPowerMetrics = &fieldsPerfPowerMetrics
	return r
}

// maximum number of related appClips returned (when they are included)
func (r AppsApiAppsGetCollectionRequest) LimitAppClips(limitAppClips int32) AppsApiAppsGetCollectionRequest {
	r.limitAppClips = &limitAppClips
	return r
}

// maximum number of related appCustomProductPages returned (when they are included)
func (r AppsApiAppsGetCollectionRequest) LimitAppCustomProductPages(limitAppCustomProductPages int32) AppsApiAppsGetCollectionRequest {
	r.limitAppCustomProductPages = &limitAppCustomProductPages
	return r
}

// maximum number of related appEvents returned (when they are included)
func (r AppsApiAppsGetCollectionRequest) LimitAppEvents(limitAppEvents int32) AppsApiAppsGetCollectionRequest {
	r.limitAppEvents = &limitAppEvents
	return r
}

// maximum number of related appInfos returned (when they are included)
func (r AppsApiAppsGetCollectionRequest) LimitAppInfos(limitAppInfos int32) AppsApiAppsGetCollectionRequest {
	r.limitAppInfos = &limitAppInfos
	return r
}

// maximum number of related appStoreVersions returned (when they are included)
func (r AppsApiAppsGetCollectionRequest) LimitAppStoreVersions(limitAppStoreVersions int32) AppsApiAppsGetCollectionRequest {
	r.limitAppStoreVersions = &limitAppStoreVersions
	return r
}

// maximum number of related availableTerritories returned (when they are included)
func (r AppsApiAppsGetCollectionRequest) LimitAvailableTerritories(limitAvailableTerritories int32) AppsApiAppsGetCollectionRequest {
	r.limitAvailableTerritories = &limitAvailableTerritories
	return r
}

// maximum number of related betaAppLocalizations returned (when they are included)
func (r AppsApiAppsGetCollectionRequest) LimitBetaAppLocalizations(limitBetaAppLocalizations int32) AppsApiAppsGetCollectionRequest {
	r.limitBetaAppLocalizations = &limitBetaAppLocalizations
	return r
}

// maximum number of related betaGroups returned (when they are included)
func (r AppsApiAppsGetCollectionRequest) LimitBetaGroups(limitBetaGroups int32) AppsApiAppsGetCollectionRequest {
	r.limitBetaGroups = &limitBetaGroups
	return r
}

// maximum number of related builds returned (when they are included)
func (r AppsApiAppsGetCollectionRequest) LimitBuilds(limitBuilds int32) AppsApiAppsGetCollectionRequest {
	r.limitBuilds = &limitBuilds
	return r
}

// maximum number of related gameCenterEnabledVersions returned (when they are included)
func (r AppsApiAppsGetCollectionRequest) LimitGameCenterEnabledVersions(limitGameCenterEnabledVersions int32) AppsApiAppsGetCollectionRequest {
	r.limitGameCenterEnabledVersions = &limitGameCenterEnabledVersions
	return r
}

// maximum number of related inAppPurchases returned (when they are included)
func (r AppsApiAppsGetCollectionRequest) LimitInAppPurchases(limitInAppPurchases int32) AppsApiAppsGetCollectionRequest {
	r.limitInAppPurchases = &limitInAppPurchases
	return r
}

// maximum number of related inAppPurchasesV2 returned (when they are included)
func (r AppsApiAppsGetCollectionRequest) LimitInAppPurchasesV2(limitInAppPurchasesV2 int32) AppsApiAppsGetCollectionRequest {
	r.limitInAppPurchasesV2 = &limitInAppPurchasesV2
	return r
}

// maximum number of related preReleaseVersions returned (when they are included)
func (r AppsApiAppsGetCollectionRequest) LimitPreReleaseVersions(limitPreReleaseVersions int32) AppsApiAppsGetCollectionRequest {
	r.limitPreReleaseVersions = &limitPreReleaseVersions
	return r
}

// maximum number of related prices returned (when they are included)
// Deprecated
func (r AppsApiAppsGetCollectionRequest) LimitPrices(limitPrices int32) AppsApiAppsGetCollectionRequest {
	r.limitPrices = &limitPrices
	return r
}

// maximum number of related promotedPurchases returned (when they are included)
func (r AppsApiAppsGetCollectionRequest) LimitPromotedPurchases(limitPromotedPurchases int32) AppsApiAppsGetCollectionRequest {
	r.limitPromotedPurchases = &limitPromotedPurchases
	return r
}

// maximum number of related reviewSubmissions returned (when they are included)
func (r AppsApiAppsGetCollectionRequest) LimitReviewSubmissions(limitReviewSubmissions int32) AppsApiAppsGetCollectionRequest {
	r.limitReviewSubmissions = &limitReviewSubmissions
	return r
}

// maximum number of related subscriptionGroups returned (when they are included)
func (r AppsApiAppsGetCollectionRequest) LimitSubscriptionGroups(limitSubscriptionGroups int32) AppsApiAppsGetCollectionRequest {
	r.limitSubscriptionGroups = &limitSubscriptionGroups
	return r
}

func (r AppsApiAppsGetCollectionRequest) Execute() (*AppsResponse, *http.Response, error) {
	return r.ApiService.AppsGetCollectionExecute(r)
}

/*
AppsGetCollection Method for AppsGetCollection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AppsApiAppsGetCollectionRequest
*/
func (a *AppsApiService) AppsGetCollection(ctx context.Context) AppsApiAppsGetCollectionRequest {
	return AppsApiAppsGetCollectionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AppsResponse
func (a *AppsApiService) AppsGetCollectionExecute(r AppsApiAppsGetCollectionRequest) (*AppsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsGetCollection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterAppStoreVersionsAppStoreState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[appStoreVersions.appStoreState]", r.filterAppStoreVersionsAppStoreState, "csv")
	}
	if r.filterAppStoreVersionsPlatform != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[appStoreVersions.platform]", r.filterAppStoreVersionsPlatform, "csv")
	}
	if r.filterBundleId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[bundleId]", r.filterBundleId, "csv")
	}
	if r.filterName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[name]", r.filterName, "csv")
	}
	if r.filterSku != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[sku]", r.filterSku, "csv")
	}
	if r.filterAppStoreVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[appStoreVersions]", r.filterAppStoreVersions, "csv")
	}
	if r.filterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[id]", r.filterId, "csv")
	}
	if r.existsGameCenterEnabledVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exists[gameCenterEnabledVersions]", r.existsGameCenterEnabledVersions, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	if r.fieldsBetaAppReviewDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaAppReviewDetails]", r.fieldsBetaAppReviewDetails, "csv")
	}
	if r.fieldsAppPriceSchedules != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPriceSchedules]", r.fieldsAppPriceSchedules, "csv")
	}
	if r.fieldsCiProducts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[ciProducts]", r.fieldsCiProducts, "csv")
	}
	if r.fieldsReviewSubmissions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[reviewSubmissions]", r.fieldsReviewSubmissions, "csv")
	}
	if r.fieldsBetaGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaGroups]", r.fieldsBetaGroups, "csv")
	}
	if r.fieldsPromotedPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchases]", r.fieldsPromotedPurchases, "csv")
	}
	if r.fieldsAppAvailabilities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appAvailabilities]", r.fieldsAppAvailabilities, "csv")
	}
	if r.fieldsCustomerReviews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[customerReviews]", r.fieldsCustomerReviews, "csv")
	}
	if r.fieldsAppEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appEvents]", r.fieldsAppEvents, "csv")
	}
	if r.fieldsBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[builds]", r.fieldsBuilds, "csv")
	}
	if r.fieldsBetaLicenseAgreements != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaLicenseAgreements]", r.fieldsBetaLicenseAgreements, "csv")
	}
	if r.fieldsAppClips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appClips]", r.fieldsAppClips, "csv")
	}
	if r.fieldsAppInfos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appInfos]", r.fieldsAppInfos, "csv")
	}
	if r.fieldsBetaAppLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaAppLocalizations]", r.fieldsBetaAppLocalizations, "csv")
	}
	if r.fieldsAppPricePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPricePoints]", r.fieldsAppPricePoints, "csv")
	}
	if r.fieldsAppPricePoints2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPricePoints]", r.fieldsAppPricePoints2, "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "csv")
	}
	if r.fieldsPreReleaseVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[preReleaseVersions]", r.fieldsPreReleaseVersions, "csv")
	}
	if r.fieldsInAppPurchases2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases2, "csv")
	}
	if r.fieldsSubscriptionGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionGroups]", r.fieldsSubscriptionGroups, "csv")
	}
	if r.fieldsAppPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPrices]", r.fieldsAppPrices, "csv")
	}
	if r.fieldsAppPreOrders != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPreOrders]", r.fieldsAppPreOrders, "csv")
	}
	if r.fieldsGameCenterEnabledVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterEnabledVersions]", r.fieldsGameCenterEnabledVersions, "csv")
	}
	if r.fieldsSubscriptionGracePeriods != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionGracePeriods]", r.fieldsSubscriptionGracePeriods, "csv")
	}
	if r.fieldsEndUserLicenseAgreements != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[endUserLicenseAgreements]", r.fieldsEndUserLicenseAgreements, "csv")
	}
	if r.fieldsAppStoreVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersions]", r.fieldsAppStoreVersions, "csv")
	}
	if r.fieldsAppCustomProductPages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCustomProductPages]", r.fieldsAppCustomProductPages, "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "csv")
	}
	if r.fieldsPerfPowerMetrics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[perfPowerMetrics]", r.fieldsPerfPowerMetrics, "csv")
	}
	if r.limitAppClips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appClips]", r.limitAppClips, "")
	}
	if r.limitAppCustomProductPages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appCustomProductPages]", r.limitAppCustomProductPages, "")
	}
	if r.limitAppEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appEvents]", r.limitAppEvents, "")
	}
	if r.limitAppInfos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appInfos]", r.limitAppInfos, "")
	}
	if r.limitAppStoreVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appStoreVersions]", r.limitAppStoreVersions, "")
	}
	if r.limitAvailableTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[availableTerritories]", r.limitAvailableTerritories, "")
	}
	if r.limitBetaAppLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[betaAppLocalizations]", r.limitBetaAppLocalizations, "")
	}
	if r.limitBetaGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[betaGroups]", r.limitBetaGroups, "")
	}
	if r.limitBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[builds]", r.limitBuilds, "")
	}
	if r.limitGameCenterEnabledVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[gameCenterEnabledVersions]", r.limitGameCenterEnabledVersions, "")
	}
	if r.limitInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[inAppPurchases]", r.limitInAppPurchases, "")
	}
	if r.limitInAppPurchasesV2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[inAppPurchasesV2]", r.limitInAppPurchasesV2, "")
	}
	if r.limitPreReleaseVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[preReleaseVersions]", r.limitPreReleaseVersions, "")
	}
	if r.limitPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[prices]", r.limitPrices, "")
	}
	if r.limitPromotedPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[promotedPurchases]", r.limitPromotedPurchases, "")
	}
	if r.limitReviewSubmissions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[reviewSubmissions]", r.limitReviewSubmissions, "")
	}
	if r.limitSubscriptionGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subscriptionGroups]", r.limitSubscriptionGroups, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsGetInstanceRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	fieldsApps *[]string
	include *[]string
	fieldsBetaAppReviewDetails *[]string
	fieldsAppPriceSchedules *[]string
	fieldsCiProducts *[]string
	fieldsReviewSubmissions *[]string
	fieldsBetaGroups *[]string
	fieldsPromotedPurchases *[]string
	fieldsAppAvailabilities *[]string
	fieldsCustomerReviews *[]string
	fieldsAppEvents *[]string
	fieldsBuilds *[]string
	fieldsBetaLicenseAgreements *[]string
	fieldsAppClips *[]string
	fieldsAppInfos *[]string
	fieldsBetaAppLocalizations *[]string
	fieldsAppPricePoints *[]string
	fieldsAppPricePoints2 *[]string
	fieldsInAppPurchases *[]string
	fieldsPreReleaseVersions *[]string
	fieldsInAppPurchases2 *[]string
	fieldsSubscriptionGroups *[]string
	fieldsAppPrices *[]string
	fieldsAppPreOrders *[]string
	fieldsGameCenterEnabledVersions *[]string
	fieldsSubscriptionGracePeriods *[]string
	fieldsEndUserLicenseAgreements *[]string
	fieldsAppStoreVersions *[]string
	fieldsAppCustomProductPages *[]string
	fieldsTerritories *[]string
	fieldsPerfPowerMetrics *[]string
	limitAppClips *int32
	limitAppCustomProductPages *int32
	limitAppEvents *int32
	limitAppInfos *int32
	limitAppStoreVersions *int32
	limitAvailableTerritories *int32
	limitBetaAppLocalizations *int32
	limitBetaGroups *int32
	limitBuilds *int32
	limitGameCenterEnabledVersions *int32
	limitInAppPurchases *int32
	limitInAppPurchasesV2 *int32
	limitPreReleaseVersions *int32
	limitPrices *int32
	limitPromotedPurchases *int32
	limitReviewSubmissions *int32
	limitSubscriptionGroups *int32
}

// the fields to include for returned resources of type apps
func (r AppsApiAppsGetInstanceRequest) FieldsApps(fieldsApps []string) AppsApiAppsGetInstanceRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// comma-separated list of relationships to include
func (r AppsApiAppsGetInstanceRequest) Include(include []string) AppsApiAppsGetInstanceRequest {
	r.include = &include
	return r
}

// the fields to include for returned resources of type betaAppReviewDetails
func (r AppsApiAppsGetInstanceRequest) FieldsBetaAppReviewDetails(fieldsBetaAppReviewDetails []string) AppsApiAppsGetInstanceRequest {
	r.fieldsBetaAppReviewDetails = &fieldsBetaAppReviewDetails
	return r
}

// the fields to include for returned resources of type appPriceSchedules
func (r AppsApiAppsGetInstanceRequest) FieldsAppPriceSchedules(fieldsAppPriceSchedules []string) AppsApiAppsGetInstanceRequest {
	r.fieldsAppPriceSchedules = &fieldsAppPriceSchedules
	return r
}

// the fields to include for returned resources of type ciProducts
func (r AppsApiAppsGetInstanceRequest) FieldsCiProducts(fieldsCiProducts []string) AppsApiAppsGetInstanceRequest {
	r.fieldsCiProducts = &fieldsCiProducts
	return r
}

// the fields to include for returned resources of type reviewSubmissions
func (r AppsApiAppsGetInstanceRequest) FieldsReviewSubmissions(fieldsReviewSubmissions []string) AppsApiAppsGetInstanceRequest {
	r.fieldsReviewSubmissions = &fieldsReviewSubmissions
	return r
}

// the fields to include for returned resources of type betaGroups
func (r AppsApiAppsGetInstanceRequest) FieldsBetaGroups(fieldsBetaGroups []string) AppsApiAppsGetInstanceRequest {
	r.fieldsBetaGroups = &fieldsBetaGroups
	return r
}

// the fields to include for returned resources of type promotedPurchases
func (r AppsApiAppsGetInstanceRequest) FieldsPromotedPurchases(fieldsPromotedPurchases []string) AppsApiAppsGetInstanceRequest {
	r.fieldsPromotedPurchases = &fieldsPromotedPurchases
	return r
}

// the fields to include for returned resources of type appAvailabilities
func (r AppsApiAppsGetInstanceRequest) FieldsAppAvailabilities(fieldsAppAvailabilities []string) AppsApiAppsGetInstanceRequest {
	r.fieldsAppAvailabilities = &fieldsAppAvailabilities
	return r
}

// the fields to include for returned resources of type customerReviews
func (r AppsApiAppsGetInstanceRequest) FieldsCustomerReviews(fieldsCustomerReviews []string) AppsApiAppsGetInstanceRequest {
	r.fieldsCustomerReviews = &fieldsCustomerReviews
	return r
}

// the fields to include for returned resources of type appEvents
func (r AppsApiAppsGetInstanceRequest) FieldsAppEvents(fieldsAppEvents []string) AppsApiAppsGetInstanceRequest {
	r.fieldsAppEvents = &fieldsAppEvents
	return r
}

// the fields to include for returned resources of type builds
func (r AppsApiAppsGetInstanceRequest) FieldsBuilds(fieldsBuilds []string) AppsApiAppsGetInstanceRequest {
	r.fieldsBuilds = &fieldsBuilds
	return r
}

// the fields to include for returned resources of type betaLicenseAgreements
func (r AppsApiAppsGetInstanceRequest) FieldsBetaLicenseAgreements(fieldsBetaLicenseAgreements []string) AppsApiAppsGetInstanceRequest {
	r.fieldsBetaLicenseAgreements = &fieldsBetaLicenseAgreements
	return r
}

// the fields to include for returned resources of type appClips
func (r AppsApiAppsGetInstanceRequest) FieldsAppClips(fieldsAppClips []string) AppsApiAppsGetInstanceRequest {
	r.fieldsAppClips = &fieldsAppClips
	return r
}

// the fields to include for returned resources of type appInfos
func (r AppsApiAppsGetInstanceRequest) FieldsAppInfos(fieldsAppInfos []string) AppsApiAppsGetInstanceRequest {
	r.fieldsAppInfos = &fieldsAppInfos
	return r
}

// the fields to include for returned resources of type betaAppLocalizations
func (r AppsApiAppsGetInstanceRequest) FieldsBetaAppLocalizations(fieldsBetaAppLocalizations []string) AppsApiAppsGetInstanceRequest {
	r.fieldsBetaAppLocalizations = &fieldsBetaAppLocalizations
	return r
}

// the fields to include for returned resources of type appPricePoints
// Deprecated
func (r AppsApiAppsGetInstanceRequest) FieldsAppPricePoints(fieldsAppPricePoints []string) AppsApiAppsGetInstanceRequest {
	r.fieldsAppPricePoints = &fieldsAppPricePoints
	return r
}

// the fields to include for returned resources of type appPricePoints
func (r AppsApiAppsGetInstanceRequest) FieldsAppPricePoints2(fieldsAppPricePoints2 []string) AppsApiAppsGetInstanceRequest {
	r.fieldsAppPricePoints2 = &fieldsAppPricePoints2
	return r
}

// the fields to include for returned resources of type inAppPurchases
// Deprecated
func (r AppsApiAppsGetInstanceRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) AppsApiAppsGetInstanceRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// the fields to include for returned resources of type preReleaseVersions
func (r AppsApiAppsGetInstanceRequest) FieldsPreReleaseVersions(fieldsPreReleaseVersions []string) AppsApiAppsGetInstanceRequest {
	r.fieldsPreReleaseVersions = &fieldsPreReleaseVersions
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r AppsApiAppsGetInstanceRequest) FieldsInAppPurchases2(fieldsInAppPurchases2 []string) AppsApiAppsGetInstanceRequest {
	r.fieldsInAppPurchases2 = &fieldsInAppPurchases2
	return r
}

// the fields to include for returned resources of type subscriptionGroups
func (r AppsApiAppsGetInstanceRequest) FieldsSubscriptionGroups(fieldsSubscriptionGroups []string) AppsApiAppsGetInstanceRequest {
	r.fieldsSubscriptionGroups = &fieldsSubscriptionGroups
	return r
}

// the fields to include for returned resources of type appPrices
// Deprecated
func (r AppsApiAppsGetInstanceRequest) FieldsAppPrices(fieldsAppPrices []string) AppsApiAppsGetInstanceRequest {
	r.fieldsAppPrices = &fieldsAppPrices
	return r
}

// the fields to include for returned resources of type appPreOrders
func (r AppsApiAppsGetInstanceRequest) FieldsAppPreOrders(fieldsAppPreOrders []string) AppsApiAppsGetInstanceRequest {
	r.fieldsAppPreOrders = &fieldsAppPreOrders
	return r
}

// the fields to include for returned resources of type gameCenterEnabledVersions
func (r AppsApiAppsGetInstanceRequest) FieldsGameCenterEnabledVersions(fieldsGameCenterEnabledVersions []string) AppsApiAppsGetInstanceRequest {
	r.fieldsGameCenterEnabledVersions = &fieldsGameCenterEnabledVersions
	return r
}

// the fields to include for returned resources of type subscriptionGracePeriods
func (r AppsApiAppsGetInstanceRequest) FieldsSubscriptionGracePeriods(fieldsSubscriptionGracePeriods []string) AppsApiAppsGetInstanceRequest {
	r.fieldsSubscriptionGracePeriods = &fieldsSubscriptionGracePeriods
	return r
}

// the fields to include for returned resources of type endUserLicenseAgreements
func (r AppsApiAppsGetInstanceRequest) FieldsEndUserLicenseAgreements(fieldsEndUserLicenseAgreements []string) AppsApiAppsGetInstanceRequest {
	r.fieldsEndUserLicenseAgreements = &fieldsEndUserLicenseAgreements
	return r
}

// the fields to include for returned resources of type appStoreVersions
func (r AppsApiAppsGetInstanceRequest) FieldsAppStoreVersions(fieldsAppStoreVersions []string) AppsApiAppsGetInstanceRequest {
	r.fieldsAppStoreVersions = &fieldsAppStoreVersions
	return r
}

// the fields to include for returned resources of type appCustomProductPages
func (r AppsApiAppsGetInstanceRequest) FieldsAppCustomProductPages(fieldsAppCustomProductPages []string) AppsApiAppsGetInstanceRequest {
	r.fieldsAppCustomProductPages = &fieldsAppCustomProductPages
	return r
}

// the fields to include for returned resources of type territories
// Deprecated
func (r AppsApiAppsGetInstanceRequest) FieldsTerritories(fieldsTerritories []string) AppsApiAppsGetInstanceRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// the fields to include for returned resources of type perfPowerMetrics
func (r AppsApiAppsGetInstanceRequest) FieldsPerfPowerMetrics(fieldsPerfPowerMetrics []string) AppsApiAppsGetInstanceRequest {
	r.fieldsPerfPowerMetrics = &fieldsPerfPowerMetrics
	return r
}

// maximum number of related appClips returned (when they are included)
func (r AppsApiAppsGetInstanceRequest) LimitAppClips(limitAppClips int32) AppsApiAppsGetInstanceRequest {
	r.limitAppClips = &limitAppClips
	return r
}

// maximum number of related appCustomProductPages returned (when they are included)
func (r AppsApiAppsGetInstanceRequest) LimitAppCustomProductPages(limitAppCustomProductPages int32) AppsApiAppsGetInstanceRequest {
	r.limitAppCustomProductPages = &limitAppCustomProductPages
	return r
}

// maximum number of related appEvents returned (when they are included)
func (r AppsApiAppsGetInstanceRequest) LimitAppEvents(limitAppEvents int32) AppsApiAppsGetInstanceRequest {
	r.limitAppEvents = &limitAppEvents
	return r
}

// maximum number of related appInfos returned (when they are included)
func (r AppsApiAppsGetInstanceRequest) LimitAppInfos(limitAppInfos int32) AppsApiAppsGetInstanceRequest {
	r.limitAppInfos = &limitAppInfos
	return r
}

// maximum number of related appStoreVersions returned (when they are included)
func (r AppsApiAppsGetInstanceRequest) LimitAppStoreVersions(limitAppStoreVersions int32) AppsApiAppsGetInstanceRequest {
	r.limitAppStoreVersions = &limitAppStoreVersions
	return r
}

// maximum number of related availableTerritories returned (when they are included)
func (r AppsApiAppsGetInstanceRequest) LimitAvailableTerritories(limitAvailableTerritories int32) AppsApiAppsGetInstanceRequest {
	r.limitAvailableTerritories = &limitAvailableTerritories
	return r
}

// maximum number of related betaAppLocalizations returned (when they are included)
func (r AppsApiAppsGetInstanceRequest) LimitBetaAppLocalizations(limitBetaAppLocalizations int32) AppsApiAppsGetInstanceRequest {
	r.limitBetaAppLocalizations = &limitBetaAppLocalizations
	return r
}

// maximum number of related betaGroups returned (when they are included)
func (r AppsApiAppsGetInstanceRequest) LimitBetaGroups(limitBetaGroups int32) AppsApiAppsGetInstanceRequest {
	r.limitBetaGroups = &limitBetaGroups
	return r
}

// maximum number of related builds returned (when they are included)
func (r AppsApiAppsGetInstanceRequest) LimitBuilds(limitBuilds int32) AppsApiAppsGetInstanceRequest {
	r.limitBuilds = &limitBuilds
	return r
}

// maximum number of related gameCenterEnabledVersions returned (when they are included)
func (r AppsApiAppsGetInstanceRequest) LimitGameCenterEnabledVersions(limitGameCenterEnabledVersions int32) AppsApiAppsGetInstanceRequest {
	r.limitGameCenterEnabledVersions = &limitGameCenterEnabledVersions
	return r
}

// maximum number of related inAppPurchases returned (when they are included)
func (r AppsApiAppsGetInstanceRequest) LimitInAppPurchases(limitInAppPurchases int32) AppsApiAppsGetInstanceRequest {
	r.limitInAppPurchases = &limitInAppPurchases
	return r
}

// maximum number of related inAppPurchasesV2 returned (when they are included)
func (r AppsApiAppsGetInstanceRequest) LimitInAppPurchasesV2(limitInAppPurchasesV2 int32) AppsApiAppsGetInstanceRequest {
	r.limitInAppPurchasesV2 = &limitInAppPurchasesV2
	return r
}

// maximum number of related preReleaseVersions returned (when they are included)
func (r AppsApiAppsGetInstanceRequest) LimitPreReleaseVersions(limitPreReleaseVersions int32) AppsApiAppsGetInstanceRequest {
	r.limitPreReleaseVersions = &limitPreReleaseVersions
	return r
}

// maximum number of related prices returned (when they are included)
// Deprecated
func (r AppsApiAppsGetInstanceRequest) LimitPrices(limitPrices int32) AppsApiAppsGetInstanceRequest {
	r.limitPrices = &limitPrices
	return r
}

// maximum number of related promotedPurchases returned (when they are included)
func (r AppsApiAppsGetInstanceRequest) LimitPromotedPurchases(limitPromotedPurchases int32) AppsApiAppsGetInstanceRequest {
	r.limitPromotedPurchases = &limitPromotedPurchases
	return r
}

// maximum number of related reviewSubmissions returned (when they are included)
func (r AppsApiAppsGetInstanceRequest) LimitReviewSubmissions(limitReviewSubmissions int32) AppsApiAppsGetInstanceRequest {
	r.limitReviewSubmissions = &limitReviewSubmissions
	return r
}

// maximum number of related subscriptionGroups returned (when they are included)
func (r AppsApiAppsGetInstanceRequest) LimitSubscriptionGroups(limitSubscriptionGroups int32) AppsApiAppsGetInstanceRequest {
	r.limitSubscriptionGroups = &limitSubscriptionGroups
	return r
}

func (r AppsApiAppsGetInstanceRequest) Execute() (*AppResponse, *http.Response, error) {
	return r.ApiService.AppsGetInstanceExecute(r)
}

/*
AppsGetInstance Method for AppsGetInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsGetInstanceRequest
*/
func (a *AppsApiService) AppsGetInstance(ctx context.Context, id string) AppsApiAppsGetInstanceRequest {
	return AppsApiAppsGetInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppResponse
func (a *AppsApiService) AppsGetInstanceExecute(r AppsApiAppsGetInstanceRequest) (*AppResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsGetInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	if r.fieldsBetaAppReviewDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaAppReviewDetails]", r.fieldsBetaAppReviewDetails, "csv")
	}
	if r.fieldsAppPriceSchedules != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPriceSchedules]", r.fieldsAppPriceSchedules, "csv")
	}
	if r.fieldsCiProducts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[ciProducts]", r.fieldsCiProducts, "csv")
	}
	if r.fieldsReviewSubmissions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[reviewSubmissions]", r.fieldsReviewSubmissions, "csv")
	}
	if r.fieldsBetaGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaGroups]", r.fieldsBetaGroups, "csv")
	}
	if r.fieldsPromotedPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchases]", r.fieldsPromotedPurchases, "csv")
	}
	if r.fieldsAppAvailabilities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appAvailabilities]", r.fieldsAppAvailabilities, "csv")
	}
	if r.fieldsCustomerReviews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[customerReviews]", r.fieldsCustomerReviews, "csv")
	}
	if r.fieldsAppEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appEvents]", r.fieldsAppEvents, "csv")
	}
	if r.fieldsBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[builds]", r.fieldsBuilds, "csv")
	}
	if r.fieldsBetaLicenseAgreements != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaLicenseAgreements]", r.fieldsBetaLicenseAgreements, "csv")
	}
	if r.fieldsAppClips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appClips]", r.fieldsAppClips, "csv")
	}
	if r.fieldsAppInfos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appInfos]", r.fieldsAppInfos, "csv")
	}
	if r.fieldsBetaAppLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaAppLocalizations]", r.fieldsBetaAppLocalizations, "csv")
	}
	if r.fieldsAppPricePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPricePoints]", r.fieldsAppPricePoints, "csv")
	}
	if r.fieldsAppPricePoints2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPricePoints]", r.fieldsAppPricePoints2, "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "csv")
	}
	if r.fieldsPreReleaseVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[preReleaseVersions]", r.fieldsPreReleaseVersions, "csv")
	}
	if r.fieldsInAppPurchases2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases2, "csv")
	}
	if r.fieldsSubscriptionGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionGroups]", r.fieldsSubscriptionGroups, "csv")
	}
	if r.fieldsAppPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPrices]", r.fieldsAppPrices, "csv")
	}
	if r.fieldsAppPreOrders != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPreOrders]", r.fieldsAppPreOrders, "csv")
	}
	if r.fieldsGameCenterEnabledVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterEnabledVersions]", r.fieldsGameCenterEnabledVersions, "csv")
	}
	if r.fieldsSubscriptionGracePeriods != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionGracePeriods]", r.fieldsSubscriptionGracePeriods, "csv")
	}
	if r.fieldsEndUserLicenseAgreements != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[endUserLicenseAgreements]", r.fieldsEndUserLicenseAgreements, "csv")
	}
	if r.fieldsAppStoreVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersions]", r.fieldsAppStoreVersions, "csv")
	}
	if r.fieldsAppCustomProductPages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCustomProductPages]", r.fieldsAppCustomProductPages, "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "csv")
	}
	if r.fieldsPerfPowerMetrics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[perfPowerMetrics]", r.fieldsPerfPowerMetrics, "csv")
	}
	if r.limitAppClips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appClips]", r.limitAppClips, "")
	}
	if r.limitAppCustomProductPages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appCustomProductPages]", r.limitAppCustomProductPages, "")
	}
	if r.limitAppEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appEvents]", r.limitAppEvents, "")
	}
	if r.limitAppInfos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appInfos]", r.limitAppInfos, "")
	}
	if r.limitAppStoreVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appStoreVersions]", r.limitAppStoreVersions, "")
	}
	if r.limitAvailableTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[availableTerritories]", r.limitAvailableTerritories, "")
	}
	if r.limitBetaAppLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[betaAppLocalizations]", r.limitBetaAppLocalizations, "")
	}
	if r.limitBetaGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[betaGroups]", r.limitBetaGroups, "")
	}
	if r.limitBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[builds]", r.limitBuilds, "")
	}
	if r.limitGameCenterEnabledVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[gameCenterEnabledVersions]", r.limitGameCenterEnabledVersions, "")
	}
	if r.limitInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[inAppPurchases]", r.limitInAppPurchases, "")
	}
	if r.limitInAppPurchasesV2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[inAppPurchasesV2]", r.limitInAppPurchasesV2, "")
	}
	if r.limitPreReleaseVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[preReleaseVersions]", r.limitPreReleaseVersions, "")
	}
	if r.limitPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[prices]", r.limitPrices, "")
	}
	if r.limitPromotedPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[promotedPurchases]", r.limitPromotedPurchases, "")
	}
	if r.limitReviewSubmissions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[reviewSubmissions]", r.limitReviewSubmissions, "")
	}
	if r.limitSubscriptionGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subscriptionGroups]", r.limitSubscriptionGroups, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsInAppPurchasesGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	filterInAppPurchaseType *[]string
	filterCanBeSubmitted *[]string
	sort *[]string
	fieldsInAppPurchases *[]string
	fieldsApps *[]string
	limit *int32
	limitApps *int32
	include *[]string
}

// filter by attribute &#39;inAppPurchaseType&#39;
func (r AppsApiAppsInAppPurchasesGetToManyRelatedRequest) FilterInAppPurchaseType(filterInAppPurchaseType []string) AppsApiAppsInAppPurchasesGetToManyRelatedRequest {
	r.filterInAppPurchaseType = &filterInAppPurchaseType
	return r
}

// filter by canBeSubmitted
func (r AppsApiAppsInAppPurchasesGetToManyRelatedRequest) FilterCanBeSubmitted(filterCanBeSubmitted []string) AppsApiAppsInAppPurchasesGetToManyRelatedRequest {
	r.filterCanBeSubmitted = &filterCanBeSubmitted
	return r
}

// comma-separated list of sort expressions; resources will be sorted as specified
func (r AppsApiAppsInAppPurchasesGetToManyRelatedRequest) Sort(sort []string) AppsApiAppsInAppPurchasesGetToManyRelatedRequest {
	r.sort = &sort
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r AppsApiAppsInAppPurchasesGetToManyRelatedRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) AppsApiAppsInAppPurchasesGetToManyRelatedRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// the fields to include for returned resources of type apps
func (r AppsApiAppsInAppPurchasesGetToManyRelatedRequest) FieldsApps(fieldsApps []string) AppsApiAppsInAppPurchasesGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// maximum resources per page
func (r AppsApiAppsInAppPurchasesGetToManyRelatedRequest) Limit(limit int32) AppsApiAppsInAppPurchasesGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// maximum number of related apps returned (when they are included)
func (r AppsApiAppsInAppPurchasesGetToManyRelatedRequest) LimitApps(limitApps int32) AppsApiAppsInAppPurchasesGetToManyRelatedRequest {
	r.limitApps = &limitApps
	return r
}

// comma-separated list of relationships to include
func (r AppsApiAppsInAppPurchasesGetToManyRelatedRequest) Include(include []string) AppsApiAppsInAppPurchasesGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r AppsApiAppsInAppPurchasesGetToManyRelatedRequest) Execute() (*InAppPurchasesResponse, *http.Response, error) {
	return r.ApiService.AppsInAppPurchasesGetToManyRelatedExecute(r)
}

/*
AppsInAppPurchasesGetToManyRelated Method for AppsInAppPurchasesGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsInAppPurchasesGetToManyRelatedRequest

Deprecated
*/
func (a *AppsApiService) AppsInAppPurchasesGetToManyRelated(ctx context.Context, id string) AppsApiAppsInAppPurchasesGetToManyRelatedRequest {
	return AppsApiAppsInAppPurchasesGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InAppPurchasesResponse
// Deprecated
func (a *AppsApiService) AppsInAppPurchasesGetToManyRelatedExecute(r AppsApiAppsInAppPurchasesGetToManyRelatedRequest) (*InAppPurchasesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchasesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsInAppPurchasesGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/inAppPurchases"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterInAppPurchaseType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[inAppPurchaseType]", r.filterInAppPurchaseType, "csv")
	}
	if r.filterCanBeSubmitted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[canBeSubmitted]", r.filterCanBeSubmitted, "csv")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.limitApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[apps]", r.limitApps, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	filterInAppPurchaseType *[]string
	filterName *[]string
	filterProductId *[]string
	filterState *[]string
	sort *[]string
	fieldsInAppPurchaseAppStoreReviewScreenshots *[]string
	fieldsInAppPurchasePricePoints *[]string
	fieldsPromotedPurchases *[]string
	fieldsInAppPurchaseLocalizations *[]string
	fieldsInAppPurchases *[]string
	fieldsInAppPurchasePriceSchedules *[]string
	fieldsInAppPurchaseContents *[]string
	limit *int32
	limitInAppPurchaseLocalizations *int32
	limitPricePoints *int32
	include *[]string
}

// filter by attribute &#39;inAppPurchaseType&#39;
func (r AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest) FilterInAppPurchaseType(filterInAppPurchaseType []string) AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.filterInAppPurchaseType = &filterInAppPurchaseType
	return r
}

// filter by attribute &#39;name&#39;
func (r AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest) FilterName(filterName []string) AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.filterName = &filterName
	return r
}

// filter by attribute &#39;productId&#39;
func (r AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest) FilterProductId(filterProductId []string) AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.filterProductId = &filterProductId
	return r
}

// filter by attribute &#39;state&#39;
func (r AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest) FilterState(filterState []string) AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.filterState = &filterState
	return r
}

// comma-separated list of sort expressions; resources will be sorted as specified
func (r AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest) Sort(sort []string) AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.sort = &sort
	return r
}

// the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots
func (r AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest) FieldsInAppPurchaseAppStoreReviewScreenshots(fieldsInAppPurchaseAppStoreReviewScreenshots []string) AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.fieldsInAppPurchaseAppStoreReviewScreenshots = &fieldsInAppPurchaseAppStoreReviewScreenshots
	return r
}

// the fields to include for returned resources of type inAppPurchasePricePoints
func (r AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest) FieldsInAppPurchasePricePoints(fieldsInAppPurchasePricePoints []string) AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.fieldsInAppPurchasePricePoints = &fieldsInAppPurchasePricePoints
	return r
}

// the fields to include for returned resources of type promotedPurchases
func (r AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest) FieldsPromotedPurchases(fieldsPromotedPurchases []string) AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.fieldsPromotedPurchases = &fieldsPromotedPurchases
	return r
}

// the fields to include for returned resources of type inAppPurchaseLocalizations
func (r AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest) FieldsInAppPurchaseLocalizations(fieldsInAppPurchaseLocalizations []string) AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.fieldsInAppPurchaseLocalizations = &fieldsInAppPurchaseLocalizations
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// the fields to include for returned resources of type inAppPurchasePriceSchedules
func (r AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest) FieldsInAppPurchasePriceSchedules(fieldsInAppPurchasePriceSchedules []string) AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.fieldsInAppPurchasePriceSchedules = &fieldsInAppPurchasePriceSchedules
	return r
}

// the fields to include for returned resources of type inAppPurchaseContents
func (r AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest) FieldsInAppPurchaseContents(fieldsInAppPurchaseContents []string) AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.fieldsInAppPurchaseContents = &fieldsInAppPurchaseContents
	return r
}

// maximum resources per page
func (r AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest) Limit(limit int32) AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// maximum number of related inAppPurchaseLocalizations returned (when they are included)
func (r AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest) LimitInAppPurchaseLocalizations(limitInAppPurchaseLocalizations int32) AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.limitInAppPurchaseLocalizations = &limitInAppPurchaseLocalizations
	return r
}

// maximum number of related pricePoints returned (when they are included)
func (r AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest) LimitPricePoints(limitPricePoints int32) AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.limitPricePoints = &limitPricePoints
	return r
}

// comma-separated list of relationships to include
func (r AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest) Include(include []string) AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest) Execute() (*InAppPurchasesV2Response, *http.Response, error) {
	return r.ApiService.AppsInAppPurchasesV2GetToManyRelatedExecute(r)
}

/*
AppsInAppPurchasesV2GetToManyRelated Method for AppsInAppPurchasesV2GetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest
*/
func (a *AppsApiService) AppsInAppPurchasesV2GetToManyRelated(ctx context.Context, id string) AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	return AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InAppPurchasesV2Response
func (a *AppsApiService) AppsInAppPurchasesV2GetToManyRelatedExecute(r AppsApiAppsInAppPurchasesV2GetToManyRelatedRequest) (*InAppPurchasesV2Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchasesV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsInAppPurchasesV2GetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/inAppPurchasesV2"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterInAppPurchaseType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[inAppPurchaseType]", r.filterInAppPurchaseType, "csv")
	}
	if r.filterName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[name]", r.filterName, "csv")
	}
	if r.filterProductId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[productId]", r.filterProductId, "csv")
	}
	if r.filterState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[state]", r.filterState, "csv")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "csv")
	}
	if r.fieldsInAppPurchaseAppStoreReviewScreenshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseAppStoreReviewScreenshots]", r.fieldsInAppPurchaseAppStoreReviewScreenshots, "csv")
	}
	if r.fieldsInAppPurchasePricePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchasePricePoints]", r.fieldsInAppPurchasePricePoints, "csv")
	}
	if r.fieldsPromotedPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchases]", r.fieldsPromotedPurchases, "csv")
	}
	if r.fieldsInAppPurchaseLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseLocalizations]", r.fieldsInAppPurchaseLocalizations, "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "csv")
	}
	if r.fieldsInAppPurchasePriceSchedules != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchasePriceSchedules]", r.fieldsInAppPurchasePriceSchedules, "csv")
	}
	if r.fieldsInAppPurchaseContents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseContents]", r.fieldsInAppPurchaseContents, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.limitInAppPurchaseLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[inAppPurchaseLocalizations]", r.limitInAppPurchaseLocalizations, "")
	}
	if r.limitPricePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[pricePoints]", r.limitPricePoints, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsPerfPowerMetricsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	filterDeviceType *[]string
	filterMetricType *[]string
	filterPlatform *[]string
}

// filter by attribute &#39;deviceType&#39;
func (r AppsApiAppsPerfPowerMetricsGetToManyRelatedRequest) FilterDeviceType(filterDeviceType []string) AppsApiAppsPerfPowerMetricsGetToManyRelatedRequest {
	r.filterDeviceType = &filterDeviceType
	return r
}

// filter by attribute &#39;metricType&#39;
func (r AppsApiAppsPerfPowerMetricsGetToManyRelatedRequest) FilterMetricType(filterMetricType []string) AppsApiAppsPerfPowerMetricsGetToManyRelatedRequest {
	r.filterMetricType = &filterMetricType
	return r
}

// filter by attribute &#39;platform&#39;
func (r AppsApiAppsPerfPowerMetricsGetToManyRelatedRequest) FilterPlatform(filterPlatform []string) AppsApiAppsPerfPowerMetricsGetToManyRelatedRequest {
	r.filterPlatform = &filterPlatform
	return r
}

func (r AppsApiAppsPerfPowerMetricsGetToManyRelatedRequest) Execute() (*XcodeMetrics, *http.Response, error) {
	return r.ApiService.AppsPerfPowerMetricsGetToManyRelatedExecute(r)
}

/*
AppsPerfPowerMetricsGetToManyRelated Method for AppsPerfPowerMetricsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsPerfPowerMetricsGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsPerfPowerMetricsGetToManyRelated(ctx context.Context, id string) AppsApiAppsPerfPowerMetricsGetToManyRelatedRequest {
	return AppsApiAppsPerfPowerMetricsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return XcodeMetrics
func (a *AppsApiService) AppsPerfPowerMetricsGetToManyRelatedExecute(r AppsApiAppsPerfPowerMetricsGetToManyRelatedRequest) (*XcodeMetrics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *XcodeMetrics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsPerfPowerMetricsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/perfPowerMetrics"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterDeviceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[deviceType]", r.filterDeviceType, "csv")
	}
	if r.filterMetricType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[metricType]", r.filterMetricType, "csv")
	}
	if r.filterPlatform != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[platform]", r.filterPlatform, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.apple.xcode-metrics+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsPreOrderGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	fieldsAppPreOrders *[]string
}

// the fields to include for returned resources of type appPreOrders
func (r AppsApiAppsPreOrderGetToOneRelatedRequest) FieldsAppPreOrders(fieldsAppPreOrders []string) AppsApiAppsPreOrderGetToOneRelatedRequest {
	r.fieldsAppPreOrders = &fieldsAppPreOrders
	return r
}

func (r AppsApiAppsPreOrderGetToOneRelatedRequest) Execute() (*AppPreOrderResponse, *http.Response, error) {
	return r.ApiService.AppsPreOrderGetToOneRelatedExecute(r)
}

/*
AppsPreOrderGetToOneRelated Method for AppsPreOrderGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsPreOrderGetToOneRelatedRequest
*/
func (a *AppsApiService) AppsPreOrderGetToOneRelated(ctx context.Context, id string) AppsApiAppsPreOrderGetToOneRelatedRequest {
	return AppsApiAppsPreOrderGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppPreOrderResponse
func (a *AppsApiService) AppsPreOrderGetToOneRelatedExecute(r AppsApiAppsPreOrderGetToOneRelatedRequest) (*AppPreOrderResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppPreOrderResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsPreOrderGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/preOrder"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppPreOrders != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPreOrders]", r.fieldsAppPreOrders, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsPreReleaseVersionsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	fieldsPreReleaseVersions *[]string
	limit *int32
}

// the fields to include for returned resources of type preReleaseVersions
func (r AppsApiAppsPreReleaseVersionsGetToManyRelatedRequest) FieldsPreReleaseVersions(fieldsPreReleaseVersions []string) AppsApiAppsPreReleaseVersionsGetToManyRelatedRequest {
	r.fieldsPreReleaseVersions = &fieldsPreReleaseVersions
	return r
}

// maximum resources per page
func (r AppsApiAppsPreReleaseVersionsGetToManyRelatedRequest) Limit(limit int32) AppsApiAppsPreReleaseVersionsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

func (r AppsApiAppsPreReleaseVersionsGetToManyRelatedRequest) Execute() (*PreReleaseVersionsResponse, *http.Response, error) {
	return r.ApiService.AppsPreReleaseVersionsGetToManyRelatedExecute(r)
}

/*
AppsPreReleaseVersionsGetToManyRelated Method for AppsPreReleaseVersionsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsPreReleaseVersionsGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsPreReleaseVersionsGetToManyRelated(ctx context.Context, id string) AppsApiAppsPreReleaseVersionsGetToManyRelatedRequest {
	return AppsApiAppsPreReleaseVersionsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PreReleaseVersionsResponse
func (a *AppsApiService) AppsPreReleaseVersionsGetToManyRelatedExecute(r AppsApiAppsPreReleaseVersionsGetToManyRelatedRequest) (*PreReleaseVersionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PreReleaseVersionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsPreReleaseVersionsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/preReleaseVersions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsPreReleaseVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[preReleaseVersions]", r.fieldsPreReleaseVersions, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsPricePointsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	filterPriceTier *[]string
	filterTerritory *[]string
	fieldsAppPriceTiers *[]string
	fieldsAppPricePoints *[]string
	fieldsApps *[]string
	fieldsTerritories *[]string
	limit *int32
	include *[]string
}

// filter by id(s) of related &#39;priceTier&#39;
// Deprecated
func (r AppsApiAppsPricePointsGetToManyRelatedRequest) FilterPriceTier(filterPriceTier []string) AppsApiAppsPricePointsGetToManyRelatedRequest {
	r.filterPriceTier = &filterPriceTier
	return r
}

// filter by id(s) of related &#39;territory&#39;
func (r AppsApiAppsPricePointsGetToManyRelatedRequest) FilterTerritory(filterTerritory []string) AppsApiAppsPricePointsGetToManyRelatedRequest {
	r.filterTerritory = &filterTerritory
	return r
}

// the fields to include for returned resources of type appPriceTiers
func (r AppsApiAppsPricePointsGetToManyRelatedRequest) FieldsAppPriceTiers(fieldsAppPriceTiers []string) AppsApiAppsPricePointsGetToManyRelatedRequest {
	r.fieldsAppPriceTiers = &fieldsAppPriceTiers
	return r
}

// the fields to include for returned resources of type appPricePoints
func (r AppsApiAppsPricePointsGetToManyRelatedRequest) FieldsAppPricePoints(fieldsAppPricePoints []string) AppsApiAppsPricePointsGetToManyRelatedRequest {
	r.fieldsAppPricePoints = &fieldsAppPricePoints
	return r
}

// the fields to include for returned resources of type apps
func (r AppsApiAppsPricePointsGetToManyRelatedRequest) FieldsApps(fieldsApps []string) AppsApiAppsPricePointsGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type territories
func (r AppsApiAppsPricePointsGetToManyRelatedRequest) FieldsTerritories(fieldsTerritories []string) AppsApiAppsPricePointsGetToManyRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// maximum resources per page
func (r AppsApiAppsPricePointsGetToManyRelatedRequest) Limit(limit int32) AppsApiAppsPricePointsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r AppsApiAppsPricePointsGetToManyRelatedRequest) Include(include []string) AppsApiAppsPricePointsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r AppsApiAppsPricePointsGetToManyRelatedRequest) Execute() (*AppPricePointsV2Response, *http.Response, error) {
	return r.ApiService.AppsPricePointsGetToManyRelatedExecute(r)
}

/*
AppsPricePointsGetToManyRelated Method for AppsPricePointsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsPricePointsGetToManyRelatedRequest

Deprecated
*/
func (a *AppsApiService) AppsPricePointsGetToManyRelated(ctx context.Context, id string) AppsApiAppsPricePointsGetToManyRelatedRequest {
	return AppsApiAppsPricePointsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppPricePointsV2Response
// Deprecated
func (a *AppsApiService) AppsPricePointsGetToManyRelatedExecute(r AppsApiAppsPricePointsGetToManyRelatedRequest) (*AppPricePointsV2Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppPricePointsV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsPricePointsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/pricePoints"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPriceTier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[priceTier]", r.filterPriceTier, "csv")
	}
	if r.filterTerritory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[territory]", r.filterTerritory, "csv")
	}
	if r.fieldsAppPriceTiers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPriceTiers]", r.fieldsAppPriceTiers, "csv")
	}
	if r.fieldsAppPricePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPricePoints]", r.fieldsAppPricePoints, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsPricesGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	fieldsAppPriceTiers *[]string
	fieldsApps *[]string
	fieldsAppPrices *[]string
	limit *int32
	include *[]string
}

// the fields to include for returned resources of type appPriceTiers
func (r AppsApiAppsPricesGetToManyRelatedRequest) FieldsAppPriceTiers(fieldsAppPriceTiers []string) AppsApiAppsPricesGetToManyRelatedRequest {
	r.fieldsAppPriceTiers = &fieldsAppPriceTiers
	return r
}

// the fields to include for returned resources of type apps
func (r AppsApiAppsPricesGetToManyRelatedRequest) FieldsApps(fieldsApps []string) AppsApiAppsPricesGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type appPrices
func (r AppsApiAppsPricesGetToManyRelatedRequest) FieldsAppPrices(fieldsAppPrices []string) AppsApiAppsPricesGetToManyRelatedRequest {
	r.fieldsAppPrices = &fieldsAppPrices
	return r
}

// maximum resources per page
func (r AppsApiAppsPricesGetToManyRelatedRequest) Limit(limit int32) AppsApiAppsPricesGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r AppsApiAppsPricesGetToManyRelatedRequest) Include(include []string) AppsApiAppsPricesGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r AppsApiAppsPricesGetToManyRelatedRequest) Execute() (*AppPricesResponse, *http.Response, error) {
	return r.ApiService.AppsPricesGetToManyRelatedExecute(r)
}

/*
AppsPricesGetToManyRelated Method for AppsPricesGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsPricesGetToManyRelatedRequest

Deprecated
*/
func (a *AppsApiService) AppsPricesGetToManyRelated(ctx context.Context, id string) AppsApiAppsPricesGetToManyRelatedRequest {
	return AppsApiAppsPricesGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppPricesResponse
// Deprecated
func (a *AppsApiService) AppsPricesGetToManyRelatedExecute(r AppsApiAppsPricesGetToManyRelatedRequest) (*AppPricesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppPricesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsPricesGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/prices"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppPriceTiers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPriceTiers]", r.fieldsAppPriceTiers, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.fieldsAppPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPrices]", r.fieldsAppPrices, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsPromotedPurchasesGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	fieldsPromotedPurchases *[]string
	fieldsSubscriptions *[]string
	fieldsInAppPurchases *[]string
	fieldsPromotedPurchaseImages *[]string
	limit *int32
	limitPromotionImages *int32
	include *[]string
}

// the fields to include for returned resources of type promotedPurchases
func (r AppsApiAppsPromotedPurchasesGetToManyRelatedRequest) FieldsPromotedPurchases(fieldsPromotedPurchases []string) AppsApiAppsPromotedPurchasesGetToManyRelatedRequest {
	r.fieldsPromotedPurchases = &fieldsPromotedPurchases
	return r
}

// the fields to include for returned resources of type subscriptions
func (r AppsApiAppsPromotedPurchasesGetToManyRelatedRequest) FieldsSubscriptions(fieldsSubscriptions []string) AppsApiAppsPromotedPurchasesGetToManyRelatedRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r AppsApiAppsPromotedPurchasesGetToManyRelatedRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) AppsApiAppsPromotedPurchasesGetToManyRelatedRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// the fields to include for returned resources of type promotedPurchaseImages
func (r AppsApiAppsPromotedPurchasesGetToManyRelatedRequest) FieldsPromotedPurchaseImages(fieldsPromotedPurchaseImages []string) AppsApiAppsPromotedPurchasesGetToManyRelatedRequest {
	r.fieldsPromotedPurchaseImages = &fieldsPromotedPurchaseImages
	return r
}

// maximum resources per page
func (r AppsApiAppsPromotedPurchasesGetToManyRelatedRequest) Limit(limit int32) AppsApiAppsPromotedPurchasesGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// maximum number of related promotionImages returned (when they are included)
func (r AppsApiAppsPromotedPurchasesGetToManyRelatedRequest) LimitPromotionImages(limitPromotionImages int32) AppsApiAppsPromotedPurchasesGetToManyRelatedRequest {
	r.limitPromotionImages = &limitPromotionImages
	return r
}

// comma-separated list of relationships to include
func (r AppsApiAppsPromotedPurchasesGetToManyRelatedRequest) Include(include []string) AppsApiAppsPromotedPurchasesGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r AppsApiAppsPromotedPurchasesGetToManyRelatedRequest) Execute() (*PromotedPurchasesResponse, *http.Response, error) {
	return r.ApiService.AppsPromotedPurchasesGetToManyRelatedExecute(r)
}

/*
AppsPromotedPurchasesGetToManyRelated Method for AppsPromotedPurchasesGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsPromotedPurchasesGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsPromotedPurchasesGetToManyRelated(ctx context.Context, id string) AppsApiAppsPromotedPurchasesGetToManyRelatedRequest {
	return AppsApiAppsPromotedPurchasesGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PromotedPurchasesResponse
func (a *AppsApiService) AppsPromotedPurchasesGetToManyRelatedExecute(r AppsApiAppsPromotedPurchasesGetToManyRelatedRequest) (*PromotedPurchasesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PromotedPurchasesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsPromotedPurchasesGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/promotedPurchases"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsPromotedPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchases]", r.fieldsPromotedPurchases, "csv")
	}
	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "csv")
	}
	if r.fieldsPromotedPurchaseImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchaseImages]", r.fieldsPromotedPurchaseImages, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.limitPromotionImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[promotionImages]", r.limitPromotionImages, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsPromotedPurchasesGetToManyRelationshipRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	limit *int32
}

// maximum resources per page
func (r AppsApiAppsPromotedPurchasesGetToManyRelationshipRequest) Limit(limit int32) AppsApiAppsPromotedPurchasesGetToManyRelationshipRequest {
	r.limit = &limit
	return r
}

func (r AppsApiAppsPromotedPurchasesGetToManyRelationshipRequest) Execute() (*AppPromotedPurchasesLinkagesResponse, *http.Response, error) {
	return r.ApiService.AppsPromotedPurchasesGetToManyRelationshipExecute(r)
}

/*
AppsPromotedPurchasesGetToManyRelationship Method for AppsPromotedPurchasesGetToManyRelationship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsPromotedPurchasesGetToManyRelationshipRequest
*/
func (a *AppsApiService) AppsPromotedPurchasesGetToManyRelationship(ctx context.Context, id string) AppsApiAppsPromotedPurchasesGetToManyRelationshipRequest {
	return AppsApiAppsPromotedPurchasesGetToManyRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppPromotedPurchasesLinkagesResponse
func (a *AppsApiService) AppsPromotedPurchasesGetToManyRelationshipExecute(r AppsApiAppsPromotedPurchasesGetToManyRelationshipRequest) (*AppPromotedPurchasesLinkagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppPromotedPurchasesLinkagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsPromotedPurchasesGetToManyRelationship")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/relationships/promotedPurchases"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsPromotedPurchasesReplaceToManyRelationshipRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	appPromotedPurchasesLinkagesRequest *AppPromotedPurchasesLinkagesRequest
}

// List of related linkages
func (r AppsApiAppsPromotedPurchasesReplaceToManyRelationshipRequest) AppPromotedPurchasesLinkagesRequest(appPromotedPurchasesLinkagesRequest AppPromotedPurchasesLinkagesRequest) AppsApiAppsPromotedPurchasesReplaceToManyRelationshipRequest {
	r.appPromotedPurchasesLinkagesRequest = &appPromotedPurchasesLinkagesRequest
	return r
}

func (r AppsApiAppsPromotedPurchasesReplaceToManyRelationshipRequest) Execute() (*http.Response, error) {
	return r.ApiService.AppsPromotedPurchasesReplaceToManyRelationshipExecute(r)
}

/*
AppsPromotedPurchasesReplaceToManyRelationship Method for AppsPromotedPurchasesReplaceToManyRelationship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsPromotedPurchasesReplaceToManyRelationshipRequest
*/
func (a *AppsApiService) AppsPromotedPurchasesReplaceToManyRelationship(ctx context.Context, id string) AppsApiAppsPromotedPurchasesReplaceToManyRelationshipRequest {
	return AppsApiAppsPromotedPurchasesReplaceToManyRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *AppsApiService) AppsPromotedPurchasesReplaceToManyRelationshipExecute(r AppsApiAppsPromotedPurchasesReplaceToManyRelationshipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsPromotedPurchasesReplaceToManyRelationship")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/relationships/promotedPurchases"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appPromotedPurchasesLinkagesRequest == nil {
		return nil, reportError("appPromotedPurchasesLinkagesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appPromotedPurchasesLinkagesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AppsApiAppsReviewSubmissionsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	filterPlatform *[]string
	filterState *[]string
	fieldsReviewSubmissionItems *[]string
	fieldsAppStoreVersions *[]string
	fieldsApps *[]string
	fieldsReviewSubmissions *[]string
	limit *int32
	limitItems *int32
	include *[]string
}

// filter by attribute &#39;platform&#39;
func (r AppsApiAppsReviewSubmissionsGetToManyRelatedRequest) FilterPlatform(filterPlatform []string) AppsApiAppsReviewSubmissionsGetToManyRelatedRequest {
	r.filterPlatform = &filterPlatform
	return r
}

// filter by attribute &#39;state&#39;
func (r AppsApiAppsReviewSubmissionsGetToManyRelatedRequest) FilterState(filterState []string) AppsApiAppsReviewSubmissionsGetToManyRelatedRequest {
	r.filterState = &filterState
	return r
}

// the fields to include for returned resources of type reviewSubmissionItems
func (r AppsApiAppsReviewSubmissionsGetToManyRelatedRequest) FieldsReviewSubmissionItems(fieldsReviewSubmissionItems []string) AppsApiAppsReviewSubmissionsGetToManyRelatedRequest {
	r.fieldsReviewSubmissionItems = &fieldsReviewSubmissionItems
	return r
}

// the fields to include for returned resources of type appStoreVersions
func (r AppsApiAppsReviewSubmissionsGetToManyRelatedRequest) FieldsAppStoreVersions(fieldsAppStoreVersions []string) AppsApiAppsReviewSubmissionsGetToManyRelatedRequest {
	r.fieldsAppStoreVersions = &fieldsAppStoreVersions
	return r
}

// the fields to include for returned resources of type apps
func (r AppsApiAppsReviewSubmissionsGetToManyRelatedRequest) FieldsApps(fieldsApps []string) AppsApiAppsReviewSubmissionsGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type reviewSubmissions
func (r AppsApiAppsReviewSubmissionsGetToManyRelatedRequest) FieldsReviewSubmissions(fieldsReviewSubmissions []string) AppsApiAppsReviewSubmissionsGetToManyRelatedRequest {
	r.fieldsReviewSubmissions = &fieldsReviewSubmissions
	return r
}

// maximum resources per page
func (r AppsApiAppsReviewSubmissionsGetToManyRelatedRequest) Limit(limit int32) AppsApiAppsReviewSubmissionsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// maximum number of related items returned (when they are included)
func (r AppsApiAppsReviewSubmissionsGetToManyRelatedRequest) LimitItems(limitItems int32) AppsApiAppsReviewSubmissionsGetToManyRelatedRequest {
	r.limitItems = &limitItems
	return r
}

// comma-separated list of relationships to include
func (r AppsApiAppsReviewSubmissionsGetToManyRelatedRequest) Include(include []string) AppsApiAppsReviewSubmissionsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r AppsApiAppsReviewSubmissionsGetToManyRelatedRequest) Execute() (*ReviewSubmissionsResponse, *http.Response, error) {
	return r.ApiService.AppsReviewSubmissionsGetToManyRelatedExecute(r)
}

/*
AppsReviewSubmissionsGetToManyRelated Method for AppsReviewSubmissionsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsReviewSubmissionsGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsReviewSubmissionsGetToManyRelated(ctx context.Context, id string) AppsApiAppsReviewSubmissionsGetToManyRelatedRequest {
	return AppsApiAppsReviewSubmissionsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ReviewSubmissionsResponse
func (a *AppsApiService) AppsReviewSubmissionsGetToManyRelatedExecute(r AppsApiAppsReviewSubmissionsGetToManyRelatedRequest) (*ReviewSubmissionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReviewSubmissionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsReviewSubmissionsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/reviewSubmissions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPlatform != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[platform]", r.filterPlatform, "csv")
	}
	if r.filterState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[state]", r.filterState, "csv")
	}
	if r.fieldsReviewSubmissionItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[reviewSubmissionItems]", r.fieldsReviewSubmissionItems, "csv")
	}
	if r.fieldsAppStoreVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersions]", r.fieldsAppStoreVersions, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.fieldsReviewSubmissions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[reviewSubmissions]", r.fieldsReviewSubmissions, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.limitItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[items]", r.limitItems, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsSubscriptionGracePeriodGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	fieldsSubscriptionGracePeriods *[]string
}

// the fields to include for returned resources of type subscriptionGracePeriods
func (r AppsApiAppsSubscriptionGracePeriodGetToOneRelatedRequest) FieldsSubscriptionGracePeriods(fieldsSubscriptionGracePeriods []string) AppsApiAppsSubscriptionGracePeriodGetToOneRelatedRequest {
	r.fieldsSubscriptionGracePeriods = &fieldsSubscriptionGracePeriods
	return r
}

func (r AppsApiAppsSubscriptionGracePeriodGetToOneRelatedRequest) Execute() (*SubscriptionGracePeriodResponse, *http.Response, error) {
	return r.ApiService.AppsSubscriptionGracePeriodGetToOneRelatedExecute(r)
}

/*
AppsSubscriptionGracePeriodGetToOneRelated Method for AppsSubscriptionGracePeriodGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsSubscriptionGracePeriodGetToOneRelatedRequest
*/
func (a *AppsApiService) AppsSubscriptionGracePeriodGetToOneRelated(ctx context.Context, id string) AppsApiAppsSubscriptionGracePeriodGetToOneRelatedRequest {
	return AppsApiAppsSubscriptionGracePeriodGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SubscriptionGracePeriodResponse
func (a *AppsApiService) AppsSubscriptionGracePeriodGetToOneRelatedExecute(r AppsApiAppsSubscriptionGracePeriodGetToOneRelatedRequest) (*SubscriptionGracePeriodResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionGracePeriodResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsSubscriptionGracePeriodGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/subscriptionGracePeriod"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsSubscriptionGracePeriods != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionGracePeriods]", r.fieldsSubscriptionGracePeriods, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsSubscriptionGroupsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	filterReferenceName *[]string
	filterSubscriptionsState *[]string
	sort *[]string
	fieldsSubscriptions *[]string
	fieldsSubscriptionGroups *[]string
	fieldsSubscriptionGroupLocalizations *[]string
	limit *int32
	limitSubscriptions *int32
	limitSubscriptionGroupLocalizations *int32
	include *[]string
}

// filter by attribute &#39;referenceName&#39;
func (r AppsApiAppsSubscriptionGroupsGetToManyRelatedRequest) FilterReferenceName(filterReferenceName []string) AppsApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	r.filterReferenceName = &filterReferenceName
	return r
}

// filter by attribute &#39;subscriptions.state&#39;
func (r AppsApiAppsSubscriptionGroupsGetToManyRelatedRequest) FilterSubscriptionsState(filterSubscriptionsState []string) AppsApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	r.filterSubscriptionsState = &filterSubscriptionsState
	return r
}

// comma-separated list of sort expressions; resources will be sorted as specified
func (r AppsApiAppsSubscriptionGroupsGetToManyRelatedRequest) Sort(sort []string) AppsApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	r.sort = &sort
	return r
}

// the fields to include for returned resources of type subscriptions
func (r AppsApiAppsSubscriptionGroupsGetToManyRelatedRequest) FieldsSubscriptions(fieldsSubscriptions []string) AppsApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// the fields to include for returned resources of type subscriptionGroups
func (r AppsApiAppsSubscriptionGroupsGetToManyRelatedRequest) FieldsSubscriptionGroups(fieldsSubscriptionGroups []string) AppsApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	r.fieldsSubscriptionGroups = &fieldsSubscriptionGroups
	return r
}

// the fields to include for returned resources of type subscriptionGroupLocalizations
func (r AppsApiAppsSubscriptionGroupsGetToManyRelatedRequest) FieldsSubscriptionGroupLocalizations(fieldsSubscriptionGroupLocalizations []string) AppsApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	r.fieldsSubscriptionGroupLocalizations = &fieldsSubscriptionGroupLocalizations
	return r
}

// maximum resources per page
func (r AppsApiAppsSubscriptionGroupsGetToManyRelatedRequest) Limit(limit int32) AppsApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// maximum number of related subscriptions returned (when they are included)
func (r AppsApiAppsSubscriptionGroupsGetToManyRelatedRequest) LimitSubscriptions(limitSubscriptions int32) AppsApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	r.limitSubscriptions = &limitSubscriptions
	return r
}

// maximum number of related subscriptionGroupLocalizations returned (when they are included)
func (r AppsApiAppsSubscriptionGroupsGetToManyRelatedRequest) LimitSubscriptionGroupLocalizations(limitSubscriptionGroupLocalizations int32) AppsApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	r.limitSubscriptionGroupLocalizations = &limitSubscriptionGroupLocalizations
	return r
}

// comma-separated list of relationships to include
func (r AppsApiAppsSubscriptionGroupsGetToManyRelatedRequest) Include(include []string) AppsApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r AppsApiAppsSubscriptionGroupsGetToManyRelatedRequest) Execute() (*SubscriptionGroupsResponse, *http.Response, error) {
	return r.ApiService.AppsSubscriptionGroupsGetToManyRelatedExecute(r)
}

/*
AppsSubscriptionGroupsGetToManyRelated Method for AppsSubscriptionGroupsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsSubscriptionGroupsGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsSubscriptionGroupsGetToManyRelated(ctx context.Context, id string) AppsApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	return AppsApiAppsSubscriptionGroupsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SubscriptionGroupsResponse
func (a *AppsApiService) AppsSubscriptionGroupsGetToManyRelatedExecute(r AppsApiAppsSubscriptionGroupsGetToManyRelatedRequest) (*SubscriptionGroupsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionGroupsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsSubscriptionGroupsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/subscriptionGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterReferenceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[referenceName]", r.filterReferenceName, "csv")
	}
	if r.filterSubscriptionsState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[subscriptions.state]", r.filterSubscriptionsState, "csv")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "csv")
	}
	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "csv")
	}
	if r.fieldsSubscriptionGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionGroups]", r.fieldsSubscriptionGroups, "csv")
	}
	if r.fieldsSubscriptionGroupLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionGroupLocalizations]", r.fieldsSubscriptionGroupLocalizations, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.limitSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subscriptions]", r.limitSubscriptions, "")
	}
	if r.limitSubscriptionGroupLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subscriptionGroupLocalizations]", r.limitSubscriptionGroupLocalizations, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AppsApiAppsUpdateInstanceRequest struct {
	ctx context.Context
	ApiService *AppsApiService
	id string
	appUpdateRequest *AppUpdateRequest
}

// App representation
func (r AppsApiAppsUpdateInstanceRequest) AppUpdateRequest(appUpdateRequest AppUpdateRequest) AppsApiAppsUpdateInstanceRequest {
	r.appUpdateRequest = &appUpdateRequest
	return r
}

func (r AppsApiAppsUpdateInstanceRequest) Execute() (*AppResponse, *http.Response, error) {
	return r.ApiService.AppsUpdateInstanceExecute(r)
}

/*
AppsUpdateInstance Method for AppsUpdateInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return AppsApiAppsUpdateInstanceRequest
*/
func (a *AppsApiService) AppsUpdateInstance(ctx context.Context, id string) AppsApiAppsUpdateInstanceRequest {
	return AppsApiAppsUpdateInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppResponse
func (a *AppsApiService) AppsUpdateInstanceExecute(r AppsApiAppsUpdateInstanceRequest) (*AppResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsUpdateInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("appUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
