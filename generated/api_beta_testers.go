/*
App Store Connect API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package appstoreopenapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// BetaTestersApiService BetaTestersApi service
type BetaTestersApiService service

type BetaTestersApiBetaTestersAppsDeleteToManyRelationshipRequest struct {
	ctx context.Context
	ApiService *BetaTestersApiService
	id string
	betaTesterAppsLinkagesRequest *BetaTesterAppsLinkagesRequest
}

// List of related linkages
func (r BetaTestersApiBetaTestersAppsDeleteToManyRelationshipRequest) BetaTesterAppsLinkagesRequest(betaTesterAppsLinkagesRequest BetaTesterAppsLinkagesRequest) BetaTestersApiBetaTestersAppsDeleteToManyRelationshipRequest {
	r.betaTesterAppsLinkagesRequest = &betaTesterAppsLinkagesRequest
	return r
}

func (r BetaTestersApiBetaTestersAppsDeleteToManyRelationshipRequest) Execute() (*http.Response, error) {
	return r.ApiService.BetaTestersAppsDeleteToManyRelationshipExecute(r)
}

/*
BetaTestersAppsDeleteToManyRelationship Method for BetaTestersAppsDeleteToManyRelationship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return BetaTestersApiBetaTestersAppsDeleteToManyRelationshipRequest
*/
func (a *BetaTestersApiService) BetaTestersAppsDeleteToManyRelationship(ctx context.Context, id string) BetaTestersApiBetaTestersAppsDeleteToManyRelationshipRequest {
	return BetaTestersApiBetaTestersAppsDeleteToManyRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *BetaTestersApiService) BetaTestersAppsDeleteToManyRelationshipExecute(r BetaTestersApiBetaTestersAppsDeleteToManyRelationshipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaTestersApiService.BetaTestersAppsDeleteToManyRelationship")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/betaTesters/{id}/relationships/apps"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.betaTesterAppsLinkagesRequest == nil {
		return nil, reportError("betaTesterAppsLinkagesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.betaTesterAppsLinkagesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type BetaTestersApiBetaTestersAppsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *BetaTestersApiService
	id string
	fieldsApps *[]string
	limit *int32
}

// the fields to include for returned resources of type apps
func (r BetaTestersApiBetaTestersAppsGetToManyRelatedRequest) FieldsApps(fieldsApps []string) BetaTestersApiBetaTestersAppsGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// maximum resources per page
func (r BetaTestersApiBetaTestersAppsGetToManyRelatedRequest) Limit(limit int32) BetaTestersApiBetaTestersAppsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

func (r BetaTestersApiBetaTestersAppsGetToManyRelatedRequest) Execute() (*AppsResponse, *http.Response, error) {
	return r.ApiService.BetaTestersAppsGetToManyRelatedExecute(r)
}

/*
BetaTestersAppsGetToManyRelated Method for BetaTestersAppsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return BetaTestersApiBetaTestersAppsGetToManyRelatedRequest
*/
func (a *BetaTestersApiService) BetaTestersAppsGetToManyRelated(ctx context.Context, id string) BetaTestersApiBetaTestersAppsGetToManyRelatedRequest {
	return BetaTestersApiBetaTestersAppsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppsResponse
func (a *BetaTestersApiService) BetaTestersAppsGetToManyRelatedExecute(r BetaTestersApiBetaTestersAppsGetToManyRelatedRequest) (*AppsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaTestersApiService.BetaTestersAppsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/betaTesters/{id}/apps"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BetaTestersApiBetaTestersAppsGetToManyRelationshipRequest struct {
	ctx context.Context
	ApiService *BetaTestersApiService
	id string
	limit *int32
}

// maximum resources per page
func (r BetaTestersApiBetaTestersAppsGetToManyRelationshipRequest) Limit(limit int32) BetaTestersApiBetaTestersAppsGetToManyRelationshipRequest {
	r.limit = &limit
	return r
}

func (r BetaTestersApiBetaTestersAppsGetToManyRelationshipRequest) Execute() (*BetaTesterAppsLinkagesResponse, *http.Response, error) {
	return r.ApiService.BetaTestersAppsGetToManyRelationshipExecute(r)
}

/*
BetaTestersAppsGetToManyRelationship Method for BetaTestersAppsGetToManyRelationship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return BetaTestersApiBetaTestersAppsGetToManyRelationshipRequest
*/
func (a *BetaTestersApiService) BetaTestersAppsGetToManyRelationship(ctx context.Context, id string) BetaTestersApiBetaTestersAppsGetToManyRelationshipRequest {
	return BetaTestersApiBetaTestersAppsGetToManyRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return BetaTesterAppsLinkagesResponse
func (a *BetaTestersApiService) BetaTestersAppsGetToManyRelationshipExecute(r BetaTestersApiBetaTestersAppsGetToManyRelationshipRequest) (*BetaTesterAppsLinkagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BetaTesterAppsLinkagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaTestersApiService.BetaTestersAppsGetToManyRelationship")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/betaTesters/{id}/relationships/apps"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BetaTestersApiBetaTestersBetaGroupsCreateToManyRelationshipRequest struct {
	ctx context.Context
	ApiService *BetaTestersApiService
	id string
	betaTesterBetaGroupsLinkagesRequest *BetaTesterBetaGroupsLinkagesRequest
}

// List of related linkages
func (r BetaTestersApiBetaTestersBetaGroupsCreateToManyRelationshipRequest) BetaTesterBetaGroupsLinkagesRequest(betaTesterBetaGroupsLinkagesRequest BetaTesterBetaGroupsLinkagesRequest) BetaTestersApiBetaTestersBetaGroupsCreateToManyRelationshipRequest {
	r.betaTesterBetaGroupsLinkagesRequest = &betaTesterBetaGroupsLinkagesRequest
	return r
}

func (r BetaTestersApiBetaTestersBetaGroupsCreateToManyRelationshipRequest) Execute() (*http.Response, error) {
	return r.ApiService.BetaTestersBetaGroupsCreateToManyRelationshipExecute(r)
}

/*
BetaTestersBetaGroupsCreateToManyRelationship Method for BetaTestersBetaGroupsCreateToManyRelationship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return BetaTestersApiBetaTestersBetaGroupsCreateToManyRelationshipRequest
*/
func (a *BetaTestersApiService) BetaTestersBetaGroupsCreateToManyRelationship(ctx context.Context, id string) BetaTestersApiBetaTestersBetaGroupsCreateToManyRelationshipRequest {
	return BetaTestersApiBetaTestersBetaGroupsCreateToManyRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *BetaTestersApiService) BetaTestersBetaGroupsCreateToManyRelationshipExecute(r BetaTestersApiBetaTestersBetaGroupsCreateToManyRelationshipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaTestersApiService.BetaTestersBetaGroupsCreateToManyRelationship")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/betaTesters/{id}/relationships/betaGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.betaTesterBetaGroupsLinkagesRequest == nil {
		return nil, reportError("betaTesterBetaGroupsLinkagesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.betaTesterBetaGroupsLinkagesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type BetaTestersApiBetaTestersBetaGroupsDeleteToManyRelationshipRequest struct {
	ctx context.Context
	ApiService *BetaTestersApiService
	id string
	betaTesterBetaGroupsLinkagesRequest *BetaTesterBetaGroupsLinkagesRequest
}

// List of related linkages
func (r BetaTestersApiBetaTestersBetaGroupsDeleteToManyRelationshipRequest) BetaTesterBetaGroupsLinkagesRequest(betaTesterBetaGroupsLinkagesRequest BetaTesterBetaGroupsLinkagesRequest) BetaTestersApiBetaTestersBetaGroupsDeleteToManyRelationshipRequest {
	r.betaTesterBetaGroupsLinkagesRequest = &betaTesterBetaGroupsLinkagesRequest
	return r
}

func (r BetaTestersApiBetaTestersBetaGroupsDeleteToManyRelationshipRequest) Execute() (*http.Response, error) {
	return r.ApiService.BetaTestersBetaGroupsDeleteToManyRelationshipExecute(r)
}

/*
BetaTestersBetaGroupsDeleteToManyRelationship Method for BetaTestersBetaGroupsDeleteToManyRelationship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return BetaTestersApiBetaTestersBetaGroupsDeleteToManyRelationshipRequest
*/
func (a *BetaTestersApiService) BetaTestersBetaGroupsDeleteToManyRelationship(ctx context.Context, id string) BetaTestersApiBetaTestersBetaGroupsDeleteToManyRelationshipRequest {
	return BetaTestersApiBetaTestersBetaGroupsDeleteToManyRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *BetaTestersApiService) BetaTestersBetaGroupsDeleteToManyRelationshipExecute(r BetaTestersApiBetaTestersBetaGroupsDeleteToManyRelationshipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaTestersApiService.BetaTestersBetaGroupsDeleteToManyRelationship")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/betaTesters/{id}/relationships/betaGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.betaTesterBetaGroupsLinkagesRequest == nil {
		return nil, reportError("betaTesterBetaGroupsLinkagesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.betaTesterBetaGroupsLinkagesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type BetaTestersApiBetaTestersBetaGroupsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *BetaTestersApiService
	id string
	fieldsBetaGroups *[]string
	limit *int32
}

// the fields to include for returned resources of type betaGroups
func (r BetaTestersApiBetaTestersBetaGroupsGetToManyRelatedRequest) FieldsBetaGroups(fieldsBetaGroups []string) BetaTestersApiBetaTestersBetaGroupsGetToManyRelatedRequest {
	r.fieldsBetaGroups = &fieldsBetaGroups
	return r
}

// maximum resources per page
func (r BetaTestersApiBetaTestersBetaGroupsGetToManyRelatedRequest) Limit(limit int32) BetaTestersApiBetaTestersBetaGroupsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

func (r BetaTestersApiBetaTestersBetaGroupsGetToManyRelatedRequest) Execute() (*BetaGroupsResponse, *http.Response, error) {
	return r.ApiService.BetaTestersBetaGroupsGetToManyRelatedExecute(r)
}

/*
BetaTestersBetaGroupsGetToManyRelated Method for BetaTestersBetaGroupsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return BetaTestersApiBetaTestersBetaGroupsGetToManyRelatedRequest
*/
func (a *BetaTestersApiService) BetaTestersBetaGroupsGetToManyRelated(ctx context.Context, id string) BetaTestersApiBetaTestersBetaGroupsGetToManyRelatedRequest {
	return BetaTestersApiBetaTestersBetaGroupsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return BetaGroupsResponse
func (a *BetaTestersApiService) BetaTestersBetaGroupsGetToManyRelatedExecute(r BetaTestersApiBetaTestersBetaGroupsGetToManyRelatedRequest) (*BetaGroupsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BetaGroupsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaTestersApiService.BetaTestersBetaGroupsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/betaTesters/{id}/betaGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsBetaGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaGroups]", r.fieldsBetaGroups, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BetaTestersApiBetaTestersBetaGroupsGetToManyRelationshipRequest struct {
	ctx context.Context
	ApiService *BetaTestersApiService
	id string
	limit *int32
}

// maximum resources per page
func (r BetaTestersApiBetaTestersBetaGroupsGetToManyRelationshipRequest) Limit(limit int32) BetaTestersApiBetaTestersBetaGroupsGetToManyRelationshipRequest {
	r.limit = &limit
	return r
}

func (r BetaTestersApiBetaTestersBetaGroupsGetToManyRelationshipRequest) Execute() (*BetaTesterBetaGroupsLinkagesResponse, *http.Response, error) {
	return r.ApiService.BetaTestersBetaGroupsGetToManyRelationshipExecute(r)
}

/*
BetaTestersBetaGroupsGetToManyRelationship Method for BetaTestersBetaGroupsGetToManyRelationship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return BetaTestersApiBetaTestersBetaGroupsGetToManyRelationshipRequest
*/
func (a *BetaTestersApiService) BetaTestersBetaGroupsGetToManyRelationship(ctx context.Context, id string) BetaTestersApiBetaTestersBetaGroupsGetToManyRelationshipRequest {
	return BetaTestersApiBetaTestersBetaGroupsGetToManyRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return BetaTesterBetaGroupsLinkagesResponse
func (a *BetaTestersApiService) BetaTestersBetaGroupsGetToManyRelationshipExecute(r BetaTestersApiBetaTestersBetaGroupsGetToManyRelationshipRequest) (*BetaTesterBetaGroupsLinkagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BetaTesterBetaGroupsLinkagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaTestersApiService.BetaTestersBetaGroupsGetToManyRelationship")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/betaTesters/{id}/relationships/betaGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BetaTestersApiBetaTestersBuildsCreateToManyRelationshipRequest struct {
	ctx context.Context
	ApiService *BetaTestersApiService
	id string
	betaTesterBuildsLinkagesRequest *BetaTesterBuildsLinkagesRequest
}

// List of related linkages
func (r BetaTestersApiBetaTestersBuildsCreateToManyRelationshipRequest) BetaTesterBuildsLinkagesRequest(betaTesterBuildsLinkagesRequest BetaTesterBuildsLinkagesRequest) BetaTestersApiBetaTestersBuildsCreateToManyRelationshipRequest {
	r.betaTesterBuildsLinkagesRequest = &betaTesterBuildsLinkagesRequest
	return r
}

func (r BetaTestersApiBetaTestersBuildsCreateToManyRelationshipRequest) Execute() (*http.Response, error) {
	return r.ApiService.BetaTestersBuildsCreateToManyRelationshipExecute(r)
}

/*
BetaTestersBuildsCreateToManyRelationship Method for BetaTestersBuildsCreateToManyRelationship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return BetaTestersApiBetaTestersBuildsCreateToManyRelationshipRequest
*/
func (a *BetaTestersApiService) BetaTestersBuildsCreateToManyRelationship(ctx context.Context, id string) BetaTestersApiBetaTestersBuildsCreateToManyRelationshipRequest {
	return BetaTestersApiBetaTestersBuildsCreateToManyRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *BetaTestersApiService) BetaTestersBuildsCreateToManyRelationshipExecute(r BetaTestersApiBetaTestersBuildsCreateToManyRelationshipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaTestersApiService.BetaTestersBuildsCreateToManyRelationship")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/betaTesters/{id}/relationships/builds"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.betaTesterBuildsLinkagesRequest == nil {
		return nil, reportError("betaTesterBuildsLinkagesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.betaTesterBuildsLinkagesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type BetaTestersApiBetaTestersBuildsDeleteToManyRelationshipRequest struct {
	ctx context.Context
	ApiService *BetaTestersApiService
	id string
	betaTesterBuildsLinkagesRequest *BetaTesterBuildsLinkagesRequest
}

// List of related linkages
func (r BetaTestersApiBetaTestersBuildsDeleteToManyRelationshipRequest) BetaTesterBuildsLinkagesRequest(betaTesterBuildsLinkagesRequest BetaTesterBuildsLinkagesRequest) BetaTestersApiBetaTestersBuildsDeleteToManyRelationshipRequest {
	r.betaTesterBuildsLinkagesRequest = &betaTesterBuildsLinkagesRequest
	return r
}

func (r BetaTestersApiBetaTestersBuildsDeleteToManyRelationshipRequest) Execute() (*http.Response, error) {
	return r.ApiService.BetaTestersBuildsDeleteToManyRelationshipExecute(r)
}

/*
BetaTestersBuildsDeleteToManyRelationship Method for BetaTestersBuildsDeleteToManyRelationship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return BetaTestersApiBetaTestersBuildsDeleteToManyRelationshipRequest
*/
func (a *BetaTestersApiService) BetaTestersBuildsDeleteToManyRelationship(ctx context.Context, id string) BetaTestersApiBetaTestersBuildsDeleteToManyRelationshipRequest {
	return BetaTestersApiBetaTestersBuildsDeleteToManyRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *BetaTestersApiService) BetaTestersBuildsDeleteToManyRelationshipExecute(r BetaTestersApiBetaTestersBuildsDeleteToManyRelationshipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaTestersApiService.BetaTestersBuildsDeleteToManyRelationship")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/betaTesters/{id}/relationships/builds"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.betaTesterBuildsLinkagesRequest == nil {
		return nil, reportError("betaTesterBuildsLinkagesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.betaTesterBuildsLinkagesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type BetaTestersApiBetaTestersBuildsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *BetaTestersApiService
	id string
	fieldsBuilds *[]string
	limit *int32
}

// the fields to include for returned resources of type builds
func (r BetaTestersApiBetaTestersBuildsGetToManyRelatedRequest) FieldsBuilds(fieldsBuilds []string) BetaTestersApiBetaTestersBuildsGetToManyRelatedRequest {
	r.fieldsBuilds = &fieldsBuilds
	return r
}

// maximum resources per page
func (r BetaTestersApiBetaTestersBuildsGetToManyRelatedRequest) Limit(limit int32) BetaTestersApiBetaTestersBuildsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

func (r BetaTestersApiBetaTestersBuildsGetToManyRelatedRequest) Execute() (*BuildsResponse, *http.Response, error) {
	return r.ApiService.BetaTestersBuildsGetToManyRelatedExecute(r)
}

/*
BetaTestersBuildsGetToManyRelated Method for BetaTestersBuildsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return BetaTestersApiBetaTestersBuildsGetToManyRelatedRequest
*/
func (a *BetaTestersApiService) BetaTestersBuildsGetToManyRelated(ctx context.Context, id string) BetaTestersApiBetaTestersBuildsGetToManyRelatedRequest {
	return BetaTestersApiBetaTestersBuildsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return BuildsResponse
func (a *BetaTestersApiService) BetaTestersBuildsGetToManyRelatedExecute(r BetaTestersApiBetaTestersBuildsGetToManyRelatedRequest) (*BuildsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BuildsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaTestersApiService.BetaTestersBuildsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/betaTesters/{id}/builds"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[builds]", r.fieldsBuilds, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BetaTestersApiBetaTestersBuildsGetToManyRelationshipRequest struct {
	ctx context.Context
	ApiService *BetaTestersApiService
	id string
	limit *int32
}

// maximum resources per page
func (r BetaTestersApiBetaTestersBuildsGetToManyRelationshipRequest) Limit(limit int32) BetaTestersApiBetaTestersBuildsGetToManyRelationshipRequest {
	r.limit = &limit
	return r
}

func (r BetaTestersApiBetaTestersBuildsGetToManyRelationshipRequest) Execute() (*BetaTesterBuildsLinkagesResponse, *http.Response, error) {
	return r.ApiService.BetaTestersBuildsGetToManyRelationshipExecute(r)
}

/*
BetaTestersBuildsGetToManyRelationship Method for BetaTestersBuildsGetToManyRelationship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return BetaTestersApiBetaTestersBuildsGetToManyRelationshipRequest
*/
func (a *BetaTestersApiService) BetaTestersBuildsGetToManyRelationship(ctx context.Context, id string) BetaTestersApiBetaTestersBuildsGetToManyRelationshipRequest {
	return BetaTestersApiBetaTestersBuildsGetToManyRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return BetaTesterBuildsLinkagesResponse
func (a *BetaTestersApiService) BetaTestersBuildsGetToManyRelationshipExecute(r BetaTestersApiBetaTestersBuildsGetToManyRelationshipRequest) (*BetaTesterBuildsLinkagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BetaTesterBuildsLinkagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaTestersApiService.BetaTestersBuildsGetToManyRelationship")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/betaTesters/{id}/relationships/builds"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BetaTestersApiBetaTestersCreateInstanceRequest struct {
	ctx context.Context
	ApiService *BetaTestersApiService
	betaTesterCreateRequest *BetaTesterCreateRequest
}

// BetaTester representation
func (r BetaTestersApiBetaTestersCreateInstanceRequest) BetaTesterCreateRequest(betaTesterCreateRequest BetaTesterCreateRequest) BetaTestersApiBetaTestersCreateInstanceRequest {
	r.betaTesterCreateRequest = &betaTesterCreateRequest
	return r
}

func (r BetaTestersApiBetaTestersCreateInstanceRequest) Execute() (*BetaTesterResponse, *http.Response, error) {
	return r.ApiService.BetaTestersCreateInstanceExecute(r)
}

/*
BetaTestersCreateInstance Method for BetaTestersCreateInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return BetaTestersApiBetaTestersCreateInstanceRequest
*/
func (a *BetaTestersApiService) BetaTestersCreateInstance(ctx context.Context) BetaTestersApiBetaTestersCreateInstanceRequest {
	return BetaTestersApiBetaTestersCreateInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BetaTesterResponse
func (a *BetaTestersApiService) BetaTestersCreateInstanceExecute(r BetaTestersApiBetaTestersCreateInstanceRequest) (*BetaTesterResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BetaTesterResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaTestersApiService.BetaTestersCreateInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/betaTesters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.betaTesterCreateRequest == nil {
		return localVarReturnValue, nil, reportError("betaTesterCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.betaTesterCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BetaTestersApiBetaTestersDeleteInstanceRequest struct {
	ctx context.Context
	ApiService *BetaTestersApiService
	id string
}

func (r BetaTestersApiBetaTestersDeleteInstanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.BetaTestersDeleteInstanceExecute(r)
}

/*
BetaTestersDeleteInstance Method for BetaTestersDeleteInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return BetaTestersApiBetaTestersDeleteInstanceRequest
*/
func (a *BetaTestersApiService) BetaTestersDeleteInstance(ctx context.Context, id string) BetaTestersApiBetaTestersDeleteInstanceRequest {
	return BetaTestersApiBetaTestersDeleteInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *BetaTestersApiService) BetaTestersDeleteInstanceExecute(r BetaTestersApiBetaTestersDeleteInstanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaTestersApiService.BetaTestersDeleteInstance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/betaTesters/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type BetaTestersApiBetaTestersGetCollectionRequest struct {
	ctx context.Context
	ApiService *BetaTestersApiService
	filterEmail *[]string
	filterFirstName *[]string
	filterInviteType *[]string
	filterLastName *[]string
	filterApps *[]string
	filterBetaGroups *[]string
	filterBuilds *[]string
	filterId *[]string
	sort *[]string
	fieldsBetaTesters *[]string
	limit *int32
	include *[]string
	fieldsApps *[]string
	fieldsBuilds *[]string
	fieldsBetaGroups *[]string
	limitApps *int32
	limitBetaGroups *int32
	limitBuilds *int32
}

// filter by attribute &#39;email&#39;
func (r BetaTestersApiBetaTestersGetCollectionRequest) FilterEmail(filterEmail []string) BetaTestersApiBetaTestersGetCollectionRequest {
	r.filterEmail = &filterEmail
	return r
}

// filter by attribute &#39;firstName&#39;
func (r BetaTestersApiBetaTestersGetCollectionRequest) FilterFirstName(filterFirstName []string) BetaTestersApiBetaTestersGetCollectionRequest {
	r.filterFirstName = &filterFirstName
	return r
}

// filter by attribute &#39;inviteType&#39;
func (r BetaTestersApiBetaTestersGetCollectionRequest) FilterInviteType(filterInviteType []string) BetaTestersApiBetaTestersGetCollectionRequest {
	r.filterInviteType = &filterInviteType
	return r
}

// filter by attribute &#39;lastName&#39;
func (r BetaTestersApiBetaTestersGetCollectionRequest) FilterLastName(filterLastName []string) BetaTestersApiBetaTestersGetCollectionRequest {
	r.filterLastName = &filterLastName
	return r
}

// filter by id(s) of related &#39;apps&#39;
func (r BetaTestersApiBetaTestersGetCollectionRequest) FilterApps(filterApps []string) BetaTestersApiBetaTestersGetCollectionRequest {
	r.filterApps = &filterApps
	return r
}

// filter by id(s) of related &#39;betaGroups&#39;
func (r BetaTestersApiBetaTestersGetCollectionRequest) FilterBetaGroups(filterBetaGroups []string) BetaTestersApiBetaTestersGetCollectionRequest {
	r.filterBetaGroups = &filterBetaGroups
	return r
}

// filter by id(s) of related &#39;builds&#39;
func (r BetaTestersApiBetaTestersGetCollectionRequest) FilterBuilds(filterBuilds []string) BetaTestersApiBetaTestersGetCollectionRequest {
	r.filterBuilds = &filterBuilds
	return r
}

// filter by id(s)
func (r BetaTestersApiBetaTestersGetCollectionRequest) FilterId(filterId []string) BetaTestersApiBetaTestersGetCollectionRequest {
	r.filterId = &filterId
	return r
}

// comma-separated list of sort expressions; resources will be sorted as specified
func (r BetaTestersApiBetaTestersGetCollectionRequest) Sort(sort []string) BetaTestersApiBetaTestersGetCollectionRequest {
	r.sort = &sort
	return r
}

// the fields to include for returned resources of type betaTesters
func (r BetaTestersApiBetaTestersGetCollectionRequest) FieldsBetaTesters(fieldsBetaTesters []string) BetaTestersApiBetaTestersGetCollectionRequest {
	r.fieldsBetaTesters = &fieldsBetaTesters
	return r
}

// maximum resources per page
func (r BetaTestersApiBetaTestersGetCollectionRequest) Limit(limit int32) BetaTestersApiBetaTestersGetCollectionRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r BetaTestersApiBetaTestersGetCollectionRequest) Include(include []string) BetaTestersApiBetaTestersGetCollectionRequest {
	r.include = &include
	return r
}

// the fields to include for returned resources of type apps
func (r BetaTestersApiBetaTestersGetCollectionRequest) FieldsApps(fieldsApps []string) BetaTestersApiBetaTestersGetCollectionRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type builds
func (r BetaTestersApiBetaTestersGetCollectionRequest) FieldsBuilds(fieldsBuilds []string) BetaTestersApiBetaTestersGetCollectionRequest {
	r.fieldsBuilds = &fieldsBuilds
	return r
}

// the fields to include for returned resources of type betaGroups
func (r BetaTestersApiBetaTestersGetCollectionRequest) FieldsBetaGroups(fieldsBetaGroups []string) BetaTestersApiBetaTestersGetCollectionRequest {
	r.fieldsBetaGroups = &fieldsBetaGroups
	return r
}

// maximum number of related apps returned (when they are included)
func (r BetaTestersApiBetaTestersGetCollectionRequest) LimitApps(limitApps int32) BetaTestersApiBetaTestersGetCollectionRequest {
	r.limitApps = &limitApps
	return r
}

// maximum number of related betaGroups returned (when they are included)
func (r BetaTestersApiBetaTestersGetCollectionRequest) LimitBetaGroups(limitBetaGroups int32) BetaTestersApiBetaTestersGetCollectionRequest {
	r.limitBetaGroups = &limitBetaGroups
	return r
}

// maximum number of related builds returned (when they are included)
func (r BetaTestersApiBetaTestersGetCollectionRequest) LimitBuilds(limitBuilds int32) BetaTestersApiBetaTestersGetCollectionRequest {
	r.limitBuilds = &limitBuilds
	return r
}

func (r BetaTestersApiBetaTestersGetCollectionRequest) Execute() (*BetaTestersResponse, *http.Response, error) {
	return r.ApiService.BetaTestersGetCollectionExecute(r)
}

/*
BetaTestersGetCollection Method for BetaTestersGetCollection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return BetaTestersApiBetaTestersGetCollectionRequest
*/
func (a *BetaTestersApiService) BetaTestersGetCollection(ctx context.Context) BetaTestersApiBetaTestersGetCollectionRequest {
	return BetaTestersApiBetaTestersGetCollectionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BetaTestersResponse
func (a *BetaTestersApiService) BetaTestersGetCollectionExecute(r BetaTestersApiBetaTestersGetCollectionRequest) (*BetaTestersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BetaTestersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaTestersApiService.BetaTestersGetCollection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/betaTesters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[email]", r.filterEmail, "csv")
	}
	if r.filterFirstName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[firstName]", r.filterFirstName, "csv")
	}
	if r.filterInviteType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[inviteType]", r.filterInviteType, "csv")
	}
	if r.filterLastName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[lastName]", r.filterLastName, "csv")
	}
	if r.filterApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[apps]", r.filterApps, "csv")
	}
	if r.filterBetaGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[betaGroups]", r.filterBetaGroups, "csv")
	}
	if r.filterBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[builds]", r.filterBuilds, "csv")
	}
	if r.filterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[id]", r.filterId, "csv")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "csv")
	}
	if r.fieldsBetaTesters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaTesters]", r.fieldsBetaTesters, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.fieldsBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[builds]", r.fieldsBuilds, "csv")
	}
	if r.fieldsBetaGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaGroups]", r.fieldsBetaGroups, "csv")
	}
	if r.limitApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[apps]", r.limitApps, "")
	}
	if r.limitBetaGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[betaGroups]", r.limitBetaGroups, "")
	}
	if r.limitBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[builds]", r.limitBuilds, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BetaTestersApiBetaTestersGetInstanceRequest struct {
	ctx context.Context
	ApiService *BetaTestersApiService
	id string
	fieldsBetaTesters *[]string
	include *[]string
	fieldsApps *[]string
	fieldsBuilds *[]string
	fieldsBetaGroups *[]string
	limitApps *int32
	limitBetaGroups *int32
	limitBuilds *int32
}

// the fields to include for returned resources of type betaTesters
func (r BetaTestersApiBetaTestersGetInstanceRequest) FieldsBetaTesters(fieldsBetaTesters []string) BetaTestersApiBetaTestersGetInstanceRequest {
	r.fieldsBetaTesters = &fieldsBetaTesters
	return r
}

// comma-separated list of relationships to include
func (r BetaTestersApiBetaTestersGetInstanceRequest) Include(include []string) BetaTestersApiBetaTestersGetInstanceRequest {
	r.include = &include
	return r
}

// the fields to include for returned resources of type apps
func (r BetaTestersApiBetaTestersGetInstanceRequest) FieldsApps(fieldsApps []string) BetaTestersApiBetaTestersGetInstanceRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type builds
func (r BetaTestersApiBetaTestersGetInstanceRequest) FieldsBuilds(fieldsBuilds []string) BetaTestersApiBetaTestersGetInstanceRequest {
	r.fieldsBuilds = &fieldsBuilds
	return r
}

// the fields to include for returned resources of type betaGroups
func (r BetaTestersApiBetaTestersGetInstanceRequest) FieldsBetaGroups(fieldsBetaGroups []string) BetaTestersApiBetaTestersGetInstanceRequest {
	r.fieldsBetaGroups = &fieldsBetaGroups
	return r
}

// maximum number of related apps returned (when they are included)
func (r BetaTestersApiBetaTestersGetInstanceRequest) LimitApps(limitApps int32) BetaTestersApiBetaTestersGetInstanceRequest {
	r.limitApps = &limitApps
	return r
}

// maximum number of related betaGroups returned (when they are included)
func (r BetaTestersApiBetaTestersGetInstanceRequest) LimitBetaGroups(limitBetaGroups int32) BetaTestersApiBetaTestersGetInstanceRequest {
	r.limitBetaGroups = &limitBetaGroups
	return r
}

// maximum number of related builds returned (when they are included)
func (r BetaTestersApiBetaTestersGetInstanceRequest) LimitBuilds(limitBuilds int32) BetaTestersApiBetaTestersGetInstanceRequest {
	r.limitBuilds = &limitBuilds
	return r
}

func (r BetaTestersApiBetaTestersGetInstanceRequest) Execute() (*BetaTesterResponse, *http.Response, error) {
	return r.ApiService.BetaTestersGetInstanceExecute(r)
}

/*
BetaTestersGetInstance Method for BetaTestersGetInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return BetaTestersApiBetaTestersGetInstanceRequest
*/
func (a *BetaTestersApiService) BetaTestersGetInstance(ctx context.Context, id string) BetaTestersApiBetaTestersGetInstanceRequest {
	return BetaTestersApiBetaTestersGetInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return BetaTesterResponse
func (a *BetaTestersApiService) BetaTestersGetInstanceExecute(r BetaTestersApiBetaTestersGetInstanceRequest) (*BetaTesterResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BetaTesterResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaTestersApiService.BetaTestersGetInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/betaTesters/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsBetaTesters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaTesters]", r.fieldsBetaTesters, "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.fieldsBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[builds]", r.fieldsBuilds, "csv")
	}
	if r.fieldsBetaGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaGroups]", r.fieldsBetaGroups, "csv")
	}
	if r.limitApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[apps]", r.limitApps, "")
	}
	if r.limitBetaGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[betaGroups]", r.limitBetaGroups, "")
	}
	if r.limitBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[builds]", r.limitBuilds, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
