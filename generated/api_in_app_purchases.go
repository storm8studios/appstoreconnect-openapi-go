/*
App Store Connect API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package appstoreopenapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// InAppPurchasesApiService InAppPurchasesApi service
type InAppPurchasesApiService service

type InAppPurchasesApiInAppPurchasesAppStoreReviewScreenshotGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesApiService
	id string
	fieldsInAppPurchaseAppStoreReviewScreenshots *[]string
	fieldsInAppPurchases *[]string
	include *[]string
}

// the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots
func (r InAppPurchasesApiInAppPurchasesAppStoreReviewScreenshotGetToOneRelatedRequest) FieldsInAppPurchaseAppStoreReviewScreenshots(fieldsInAppPurchaseAppStoreReviewScreenshots []string) InAppPurchasesApiInAppPurchasesAppStoreReviewScreenshotGetToOneRelatedRequest {
	r.fieldsInAppPurchaseAppStoreReviewScreenshots = &fieldsInAppPurchaseAppStoreReviewScreenshots
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r InAppPurchasesApiInAppPurchasesAppStoreReviewScreenshotGetToOneRelatedRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) InAppPurchasesApiInAppPurchasesAppStoreReviewScreenshotGetToOneRelatedRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// comma-separated list of relationships to include
func (r InAppPurchasesApiInAppPurchasesAppStoreReviewScreenshotGetToOneRelatedRequest) Include(include []string) InAppPurchasesApiInAppPurchasesAppStoreReviewScreenshotGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r InAppPurchasesApiInAppPurchasesAppStoreReviewScreenshotGetToOneRelatedRequest) Execute() (*InAppPurchaseAppStoreReviewScreenshotResponse, *http.Response, error) {
	return r.ApiService.InAppPurchasesAppStoreReviewScreenshotGetToOneRelatedExecute(r)
}

/*
InAppPurchasesAppStoreReviewScreenshotGetToOneRelated Method for InAppPurchasesAppStoreReviewScreenshotGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return InAppPurchasesApiInAppPurchasesAppStoreReviewScreenshotGetToOneRelatedRequest
*/
func (a *InAppPurchasesApiService) InAppPurchasesAppStoreReviewScreenshotGetToOneRelated(ctx context.Context, id string) InAppPurchasesApiInAppPurchasesAppStoreReviewScreenshotGetToOneRelatedRequest {
	return InAppPurchasesApiInAppPurchasesAppStoreReviewScreenshotGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InAppPurchaseAppStoreReviewScreenshotResponse
func (a *InAppPurchasesApiService) InAppPurchasesAppStoreReviewScreenshotGetToOneRelatedExecute(r InAppPurchasesApiInAppPurchasesAppStoreReviewScreenshotGetToOneRelatedRequest) (*InAppPurchaseAppStoreReviewScreenshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchaseAppStoreReviewScreenshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesApiService.InAppPurchasesAppStoreReviewScreenshotGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases/{id}/appStoreReviewScreenshot"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsInAppPurchaseAppStoreReviewScreenshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseAppStoreReviewScreenshots]", r.fieldsInAppPurchaseAppStoreReviewScreenshots, "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InAppPurchasesApiInAppPurchasesContentGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesApiService
	id string
	fieldsInAppPurchases *[]string
	fieldsInAppPurchaseContents *[]string
	include *[]string
}

// the fields to include for returned resources of type inAppPurchases
func (r InAppPurchasesApiInAppPurchasesContentGetToOneRelatedRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) InAppPurchasesApiInAppPurchasesContentGetToOneRelatedRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// the fields to include for returned resources of type inAppPurchaseContents
func (r InAppPurchasesApiInAppPurchasesContentGetToOneRelatedRequest) FieldsInAppPurchaseContents(fieldsInAppPurchaseContents []string) InAppPurchasesApiInAppPurchasesContentGetToOneRelatedRequest {
	r.fieldsInAppPurchaseContents = &fieldsInAppPurchaseContents
	return r
}

// comma-separated list of relationships to include
func (r InAppPurchasesApiInAppPurchasesContentGetToOneRelatedRequest) Include(include []string) InAppPurchasesApiInAppPurchasesContentGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r InAppPurchasesApiInAppPurchasesContentGetToOneRelatedRequest) Execute() (*InAppPurchaseContentResponse, *http.Response, error) {
	return r.ApiService.InAppPurchasesContentGetToOneRelatedExecute(r)
}

/*
InAppPurchasesContentGetToOneRelated Method for InAppPurchasesContentGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return InAppPurchasesApiInAppPurchasesContentGetToOneRelatedRequest
*/
func (a *InAppPurchasesApiService) InAppPurchasesContentGetToOneRelated(ctx context.Context, id string) InAppPurchasesApiInAppPurchasesContentGetToOneRelatedRequest {
	return InAppPurchasesApiInAppPurchasesContentGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InAppPurchaseContentResponse
func (a *InAppPurchasesApiService) InAppPurchasesContentGetToOneRelatedExecute(r InAppPurchasesApiInAppPurchasesContentGetToOneRelatedRequest) (*InAppPurchaseContentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchaseContentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesApiService.InAppPurchasesContentGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases/{id}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "csv")
	}
	if r.fieldsInAppPurchaseContents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseContents]", r.fieldsInAppPurchaseContents, "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InAppPurchasesApiInAppPurchasesCreateInstanceRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesApiService
	inAppPurchaseV2CreateRequest *InAppPurchaseV2CreateRequest
}

// InAppPurchase representation
func (r InAppPurchasesApiInAppPurchasesCreateInstanceRequest) InAppPurchaseV2CreateRequest(inAppPurchaseV2CreateRequest InAppPurchaseV2CreateRequest) InAppPurchasesApiInAppPurchasesCreateInstanceRequest {
	r.inAppPurchaseV2CreateRequest = &inAppPurchaseV2CreateRequest
	return r
}

func (r InAppPurchasesApiInAppPurchasesCreateInstanceRequest) Execute() (*InAppPurchaseV2Response, *http.Response, error) {
	return r.ApiService.InAppPurchasesCreateInstanceExecute(r)
}

/*
InAppPurchasesCreateInstance Method for InAppPurchasesCreateInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InAppPurchasesApiInAppPurchasesCreateInstanceRequest
*/
func (a *InAppPurchasesApiService) InAppPurchasesCreateInstance(ctx context.Context) InAppPurchasesApiInAppPurchasesCreateInstanceRequest {
	return InAppPurchasesApiInAppPurchasesCreateInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InAppPurchaseV2Response
func (a *InAppPurchasesApiService) InAppPurchasesCreateInstanceExecute(r InAppPurchasesApiInAppPurchasesCreateInstanceRequest) (*InAppPurchaseV2Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchaseV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesApiService.InAppPurchasesCreateInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.inAppPurchaseV2CreateRequest == nil {
		return localVarReturnValue, nil, reportError("inAppPurchaseV2CreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inAppPurchaseV2CreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InAppPurchasesApiInAppPurchasesDeleteInstanceRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesApiService
	id string
}

func (r InAppPurchasesApiInAppPurchasesDeleteInstanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.InAppPurchasesDeleteInstanceExecute(r)
}

/*
InAppPurchasesDeleteInstance Method for InAppPurchasesDeleteInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return InAppPurchasesApiInAppPurchasesDeleteInstanceRequest
*/
func (a *InAppPurchasesApiService) InAppPurchasesDeleteInstance(ctx context.Context, id string) InAppPurchasesApiInAppPurchasesDeleteInstanceRequest {
	return InAppPurchasesApiInAppPurchasesDeleteInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *InAppPurchasesApiService) InAppPurchasesDeleteInstanceExecute(r InAppPurchasesApiInAppPurchasesDeleteInstanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesApiService.InAppPurchasesDeleteInstance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type InAppPurchasesApiInAppPurchasesGetInstanceRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesApiService
	id string
	fieldsInAppPurchases *[]string
	include *[]string
	limitApps *int32
}

// the fields to include for returned resources of type inAppPurchases
func (r InAppPurchasesApiInAppPurchasesGetInstanceRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) InAppPurchasesApiInAppPurchasesGetInstanceRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// comma-separated list of relationships to include
func (r InAppPurchasesApiInAppPurchasesGetInstanceRequest) Include(include []string) InAppPurchasesApiInAppPurchasesGetInstanceRequest {
	r.include = &include
	return r
}

// maximum number of related apps returned (when they are included)
func (r InAppPurchasesApiInAppPurchasesGetInstanceRequest) LimitApps(limitApps int32) InAppPurchasesApiInAppPurchasesGetInstanceRequest {
	r.limitApps = &limitApps
	return r
}

func (r InAppPurchasesApiInAppPurchasesGetInstanceRequest) Execute() (*InAppPurchaseResponse, *http.Response, error) {
	return r.ApiService.InAppPurchasesGetInstanceExecute(r)
}

/*
InAppPurchasesGetInstance Method for InAppPurchasesGetInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return InAppPurchasesApiInAppPurchasesGetInstanceRequest
*/
func (a *InAppPurchasesApiService) InAppPurchasesGetInstance(ctx context.Context, id string) InAppPurchasesApiInAppPurchasesGetInstanceRequest {
	return InAppPurchasesApiInAppPurchasesGetInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InAppPurchaseResponse
func (a *InAppPurchasesApiService) InAppPurchasesGetInstanceExecute(r InAppPurchasesApiInAppPurchasesGetInstanceRequest) (*InAppPurchaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesApiService.InAppPurchasesGetInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/inAppPurchases/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	if r.limitApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[apps]", r.limitApps, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InAppPurchasesApiInAppPurchasesGetInstance_0Request struct {
	ctx context.Context
	ApiService *InAppPurchasesApiService
	id string
	fieldsInAppPurchases *[]string
	include *[]string
	fieldsInAppPurchaseAppStoreReviewScreenshots *[]string
	fieldsPromotedPurchases *[]string
	fieldsInAppPurchasePricePoints *[]string
	fieldsInAppPurchaseLocalizations *[]string
	fieldsInAppPurchasePriceSchedules *[]string
	fieldsInAppPurchaseContents *[]string
	limitInAppPurchaseLocalizations *int32
	limitPricePoints *int32
}

// the fields to include for returned resources of type inAppPurchases
func (r InAppPurchasesApiInAppPurchasesGetInstance_0Request) FieldsInAppPurchases(fieldsInAppPurchases []string) InAppPurchasesApiInAppPurchasesGetInstance_0Request {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// comma-separated list of relationships to include
func (r InAppPurchasesApiInAppPurchasesGetInstance_0Request) Include(include []string) InAppPurchasesApiInAppPurchasesGetInstance_0Request {
	r.include = &include
	return r
}

// the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots
func (r InAppPurchasesApiInAppPurchasesGetInstance_0Request) FieldsInAppPurchaseAppStoreReviewScreenshots(fieldsInAppPurchaseAppStoreReviewScreenshots []string) InAppPurchasesApiInAppPurchasesGetInstance_0Request {
	r.fieldsInAppPurchaseAppStoreReviewScreenshots = &fieldsInAppPurchaseAppStoreReviewScreenshots
	return r
}

// the fields to include for returned resources of type promotedPurchases
func (r InAppPurchasesApiInAppPurchasesGetInstance_0Request) FieldsPromotedPurchases(fieldsPromotedPurchases []string) InAppPurchasesApiInAppPurchasesGetInstance_0Request {
	r.fieldsPromotedPurchases = &fieldsPromotedPurchases
	return r
}

// the fields to include for returned resources of type inAppPurchasePricePoints
func (r InAppPurchasesApiInAppPurchasesGetInstance_0Request) FieldsInAppPurchasePricePoints(fieldsInAppPurchasePricePoints []string) InAppPurchasesApiInAppPurchasesGetInstance_0Request {
	r.fieldsInAppPurchasePricePoints = &fieldsInAppPurchasePricePoints
	return r
}

// the fields to include for returned resources of type inAppPurchaseLocalizations
func (r InAppPurchasesApiInAppPurchasesGetInstance_0Request) FieldsInAppPurchaseLocalizations(fieldsInAppPurchaseLocalizations []string) InAppPurchasesApiInAppPurchasesGetInstance_0Request {
	r.fieldsInAppPurchaseLocalizations = &fieldsInAppPurchaseLocalizations
	return r
}

// the fields to include for returned resources of type inAppPurchasePriceSchedules
func (r InAppPurchasesApiInAppPurchasesGetInstance_0Request) FieldsInAppPurchasePriceSchedules(fieldsInAppPurchasePriceSchedules []string) InAppPurchasesApiInAppPurchasesGetInstance_0Request {
	r.fieldsInAppPurchasePriceSchedules = &fieldsInAppPurchasePriceSchedules
	return r
}

// the fields to include for returned resources of type inAppPurchaseContents
func (r InAppPurchasesApiInAppPurchasesGetInstance_0Request) FieldsInAppPurchaseContents(fieldsInAppPurchaseContents []string) InAppPurchasesApiInAppPurchasesGetInstance_0Request {
	r.fieldsInAppPurchaseContents = &fieldsInAppPurchaseContents
	return r
}

// maximum number of related inAppPurchaseLocalizations returned (when they are included)
func (r InAppPurchasesApiInAppPurchasesGetInstance_0Request) LimitInAppPurchaseLocalizations(limitInAppPurchaseLocalizations int32) InAppPurchasesApiInAppPurchasesGetInstance_0Request {
	r.limitInAppPurchaseLocalizations = &limitInAppPurchaseLocalizations
	return r
}

// maximum number of related pricePoints returned (when they are included)
func (r InAppPurchasesApiInAppPurchasesGetInstance_0Request) LimitPricePoints(limitPricePoints int32) InAppPurchasesApiInAppPurchasesGetInstance_0Request {
	r.limitPricePoints = &limitPricePoints
	return r
}

func (r InAppPurchasesApiInAppPurchasesGetInstance_0Request) Execute() (*InAppPurchaseV2Response, *http.Response, error) {
	return r.ApiService.InAppPurchasesGetInstance_1Execute(r)
}

/*
InAppPurchasesGetInstance_0 Method for InAppPurchasesGetInstance_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return InAppPurchasesApiInAppPurchasesGetInstance_0Request
*/
func (a *InAppPurchasesApiService) InAppPurchasesGetInstance_1(ctx context.Context, id string) InAppPurchasesApiInAppPurchasesGetInstance_0Request {
	return InAppPurchasesApiInAppPurchasesGetInstance_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InAppPurchaseV2Response
func (a *InAppPurchasesApiService) InAppPurchasesGetInstance_1Execute(r InAppPurchasesApiInAppPurchasesGetInstance_0Request) (*InAppPurchaseV2Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchaseV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesApiService.InAppPurchasesGetInstance_1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	if r.fieldsInAppPurchaseAppStoreReviewScreenshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseAppStoreReviewScreenshots]", r.fieldsInAppPurchaseAppStoreReviewScreenshots, "csv")
	}
	if r.fieldsPromotedPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchases]", r.fieldsPromotedPurchases, "csv")
	}
	if r.fieldsInAppPurchasePricePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchasePricePoints]", r.fieldsInAppPurchasePricePoints, "csv")
	}
	if r.fieldsInAppPurchaseLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseLocalizations]", r.fieldsInAppPurchaseLocalizations, "csv")
	}
	if r.fieldsInAppPurchasePriceSchedules != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchasePriceSchedules]", r.fieldsInAppPurchasePriceSchedules, "csv")
	}
	if r.fieldsInAppPurchaseContents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseContents]", r.fieldsInAppPurchaseContents, "csv")
	}
	if r.limitInAppPurchaseLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[inAppPurchaseLocalizations]", r.limitInAppPurchaseLocalizations, "")
	}
	if r.limitPricePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[pricePoints]", r.limitPricePoints, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InAppPurchasesApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesApiService
	id string
	fieldsInAppPurchasePrices *[]string
	fieldsInAppPurchases *[]string
	fieldsInAppPurchasePriceSchedules *[]string
	fieldsTerritories *[]string
	limitManualPrices *int32
	limitAutomaticPrices *int32
	include *[]string
}

// the fields to include for returned resources of type inAppPurchasePrices
func (r InAppPurchasesApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest) FieldsInAppPurchasePrices(fieldsInAppPurchasePrices []string) InAppPurchasesApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest {
	r.fieldsInAppPurchasePrices = &fieldsInAppPurchasePrices
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r InAppPurchasesApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) InAppPurchasesApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// the fields to include for returned resources of type inAppPurchasePriceSchedules
func (r InAppPurchasesApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest) FieldsInAppPurchasePriceSchedules(fieldsInAppPurchasePriceSchedules []string) InAppPurchasesApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest {
	r.fieldsInAppPurchasePriceSchedules = &fieldsInAppPurchasePriceSchedules
	return r
}

// the fields to include for returned resources of type territories
func (r InAppPurchasesApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest) FieldsTerritories(fieldsTerritories []string) InAppPurchasesApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// maximum number of related manualPrices returned (when they are included)
func (r InAppPurchasesApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest) LimitManualPrices(limitManualPrices int32) InAppPurchasesApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest {
	r.limitManualPrices = &limitManualPrices
	return r
}

// maximum number of related automaticPrices returned (when they are included)
func (r InAppPurchasesApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest) LimitAutomaticPrices(limitAutomaticPrices int32) InAppPurchasesApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest {
	r.limitAutomaticPrices = &limitAutomaticPrices
	return r
}

// comma-separated list of relationships to include
func (r InAppPurchasesApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest) Include(include []string) InAppPurchasesApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r InAppPurchasesApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest) Execute() (*InAppPurchasePriceScheduleResponse, *http.Response, error) {
	return r.ApiService.InAppPurchasesIapPriceScheduleGetToOneRelatedExecute(r)
}

/*
InAppPurchasesIapPriceScheduleGetToOneRelated Method for InAppPurchasesIapPriceScheduleGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return InAppPurchasesApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest
*/
func (a *InAppPurchasesApiService) InAppPurchasesIapPriceScheduleGetToOneRelated(ctx context.Context, id string) InAppPurchasesApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest {
	return InAppPurchasesApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InAppPurchasePriceScheduleResponse
func (a *InAppPurchasesApiService) InAppPurchasesIapPriceScheduleGetToOneRelatedExecute(r InAppPurchasesApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest) (*InAppPurchasePriceScheduleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchasePriceScheduleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesApiService.InAppPurchasesIapPriceScheduleGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases/{id}/iapPriceSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsInAppPurchasePrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchasePrices]", r.fieldsInAppPurchasePrices, "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "csv")
	}
	if r.fieldsInAppPurchasePriceSchedules != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchasePriceSchedules]", r.fieldsInAppPurchasePriceSchedules, "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "csv")
	}
	if r.limitManualPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[manualPrices]", r.limitManualPrices, "")
	}
	if r.limitAutomaticPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[automaticPrices]", r.limitAutomaticPrices, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InAppPurchasesApiInAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesApiService
	id string
	fieldsInAppPurchaseLocalizations *[]string
	fieldsInAppPurchases *[]string
	limit *int32
	include *[]string
}

// the fields to include for returned resources of type inAppPurchaseLocalizations
func (r InAppPurchasesApiInAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedRequest) FieldsInAppPurchaseLocalizations(fieldsInAppPurchaseLocalizations []string) InAppPurchasesApiInAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedRequest {
	r.fieldsInAppPurchaseLocalizations = &fieldsInAppPurchaseLocalizations
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r InAppPurchasesApiInAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) InAppPurchasesApiInAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// maximum resources per page
func (r InAppPurchasesApiInAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedRequest) Limit(limit int32) InAppPurchasesApiInAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r InAppPurchasesApiInAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedRequest) Include(include []string) InAppPurchasesApiInAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r InAppPurchasesApiInAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedRequest) Execute() (*InAppPurchaseLocalizationsResponse, *http.Response, error) {
	return r.ApiService.InAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedExecute(r)
}

/*
InAppPurchasesInAppPurchaseLocalizationsGetToManyRelated Method for InAppPurchasesInAppPurchaseLocalizationsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return InAppPurchasesApiInAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedRequest
*/
func (a *InAppPurchasesApiService) InAppPurchasesInAppPurchaseLocalizationsGetToManyRelated(ctx context.Context, id string) InAppPurchasesApiInAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedRequest {
	return InAppPurchasesApiInAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InAppPurchaseLocalizationsResponse
func (a *InAppPurchasesApiService) InAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedExecute(r InAppPurchasesApiInAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedRequest) (*InAppPurchaseLocalizationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchaseLocalizationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesApiService.InAppPurchasesInAppPurchaseLocalizationsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases/{id}/inAppPurchaseLocalizations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsInAppPurchaseLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseLocalizations]", r.fieldsInAppPurchaseLocalizations, "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InAppPurchasesApiInAppPurchasesPricePointsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesApiService
	id string
	filterPriceTier *[]string
	filterTerritory *[]string
	fieldsInAppPurchasePricePoints *[]string
	fieldsTerritories *[]string
	limit *int32
	include *[]string
}

// filter by attribute &#39;priceTier&#39;
func (r InAppPurchasesApiInAppPurchasesPricePointsGetToManyRelatedRequest) FilterPriceTier(filterPriceTier []string) InAppPurchasesApiInAppPurchasesPricePointsGetToManyRelatedRequest {
	r.filterPriceTier = &filterPriceTier
	return r
}

// filter by id(s) of related &#39;territory&#39;
func (r InAppPurchasesApiInAppPurchasesPricePointsGetToManyRelatedRequest) FilterTerritory(filterTerritory []string) InAppPurchasesApiInAppPurchasesPricePointsGetToManyRelatedRequest {
	r.filterTerritory = &filterTerritory
	return r
}

// the fields to include for returned resources of type inAppPurchasePricePoints
func (r InAppPurchasesApiInAppPurchasesPricePointsGetToManyRelatedRequest) FieldsInAppPurchasePricePoints(fieldsInAppPurchasePricePoints []string) InAppPurchasesApiInAppPurchasesPricePointsGetToManyRelatedRequest {
	r.fieldsInAppPurchasePricePoints = &fieldsInAppPurchasePricePoints
	return r
}

// the fields to include for returned resources of type territories
func (r InAppPurchasesApiInAppPurchasesPricePointsGetToManyRelatedRequest) FieldsTerritories(fieldsTerritories []string) InAppPurchasesApiInAppPurchasesPricePointsGetToManyRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// maximum resources per page
func (r InAppPurchasesApiInAppPurchasesPricePointsGetToManyRelatedRequest) Limit(limit int32) InAppPurchasesApiInAppPurchasesPricePointsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r InAppPurchasesApiInAppPurchasesPricePointsGetToManyRelatedRequest) Include(include []string) InAppPurchasesApiInAppPurchasesPricePointsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r InAppPurchasesApiInAppPurchasesPricePointsGetToManyRelatedRequest) Execute() (*InAppPurchasePricePointsResponse, *http.Response, error) {
	return r.ApiService.InAppPurchasesPricePointsGetToManyRelatedExecute(r)
}

/*
InAppPurchasesPricePointsGetToManyRelated Method for InAppPurchasesPricePointsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return InAppPurchasesApiInAppPurchasesPricePointsGetToManyRelatedRequest
*/
func (a *InAppPurchasesApiService) InAppPurchasesPricePointsGetToManyRelated(ctx context.Context, id string) InAppPurchasesApiInAppPurchasesPricePointsGetToManyRelatedRequest {
	return InAppPurchasesApiInAppPurchasesPricePointsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InAppPurchasePricePointsResponse
func (a *InAppPurchasesApiService) InAppPurchasesPricePointsGetToManyRelatedExecute(r InAppPurchasesApiInAppPurchasesPricePointsGetToManyRelatedRequest) (*InAppPurchasePricePointsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchasePricePointsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesApiService.InAppPurchasesPricePointsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases/{id}/pricePoints"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPriceTier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[priceTier]", r.filterPriceTier, "csv")
	}
	if r.filterTerritory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[territory]", r.filterTerritory, "csv")
	}
	if r.fieldsInAppPurchasePricePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchasePricePoints]", r.fieldsInAppPurchasePricePoints, "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InAppPurchasesApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesApiService
	id string
	fieldsPromotedPurchases *[]string
	fieldsSubscriptions *[]string
	fieldsInAppPurchases *[]string
	fieldsPromotedPurchaseImages *[]string
	limitPromotionImages *int32
	include *[]string
}

// the fields to include for returned resources of type promotedPurchases
func (r InAppPurchasesApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest) FieldsPromotedPurchases(fieldsPromotedPurchases []string) InAppPurchasesApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest {
	r.fieldsPromotedPurchases = &fieldsPromotedPurchases
	return r
}

// the fields to include for returned resources of type subscriptions
func (r InAppPurchasesApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest) FieldsSubscriptions(fieldsSubscriptions []string) InAppPurchasesApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r InAppPurchasesApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) InAppPurchasesApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// the fields to include for returned resources of type promotedPurchaseImages
func (r InAppPurchasesApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest) FieldsPromotedPurchaseImages(fieldsPromotedPurchaseImages []string) InAppPurchasesApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest {
	r.fieldsPromotedPurchaseImages = &fieldsPromotedPurchaseImages
	return r
}

// maximum number of related promotionImages returned (when they are included)
func (r InAppPurchasesApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest) LimitPromotionImages(limitPromotionImages int32) InAppPurchasesApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest {
	r.limitPromotionImages = &limitPromotionImages
	return r
}

// comma-separated list of relationships to include
func (r InAppPurchasesApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest) Include(include []string) InAppPurchasesApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r InAppPurchasesApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest) Execute() (*PromotedPurchaseResponse, *http.Response, error) {
	return r.ApiService.InAppPurchasesPromotedPurchaseGetToOneRelatedExecute(r)
}

/*
InAppPurchasesPromotedPurchaseGetToOneRelated Method for InAppPurchasesPromotedPurchaseGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return InAppPurchasesApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest
*/
func (a *InAppPurchasesApiService) InAppPurchasesPromotedPurchaseGetToOneRelated(ctx context.Context, id string) InAppPurchasesApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest {
	return InAppPurchasesApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PromotedPurchaseResponse
func (a *InAppPurchasesApiService) InAppPurchasesPromotedPurchaseGetToOneRelatedExecute(r InAppPurchasesApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest) (*PromotedPurchaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PromotedPurchaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesApiService.InAppPurchasesPromotedPurchaseGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases/{id}/promotedPurchase"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsPromotedPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchases]", r.fieldsPromotedPurchases, "csv")
	}
	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "csv")
	}
	if r.fieldsPromotedPurchaseImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchaseImages]", r.fieldsPromotedPurchaseImages, "csv")
	}
	if r.limitPromotionImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[promotionImages]", r.limitPromotionImages, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InAppPurchasesApiInAppPurchasesUpdateInstanceRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesApiService
	id string
	inAppPurchaseV2UpdateRequest *InAppPurchaseV2UpdateRequest
}

// InAppPurchase representation
func (r InAppPurchasesApiInAppPurchasesUpdateInstanceRequest) InAppPurchaseV2UpdateRequest(inAppPurchaseV2UpdateRequest InAppPurchaseV2UpdateRequest) InAppPurchasesApiInAppPurchasesUpdateInstanceRequest {
	r.inAppPurchaseV2UpdateRequest = &inAppPurchaseV2UpdateRequest
	return r
}

func (r InAppPurchasesApiInAppPurchasesUpdateInstanceRequest) Execute() (*InAppPurchaseV2Response, *http.Response, error) {
	return r.ApiService.InAppPurchasesUpdateInstanceExecute(r)
}

/*
InAppPurchasesUpdateInstance Method for InAppPurchasesUpdateInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return InAppPurchasesApiInAppPurchasesUpdateInstanceRequest
*/
func (a *InAppPurchasesApiService) InAppPurchasesUpdateInstance(ctx context.Context, id string) InAppPurchasesApiInAppPurchasesUpdateInstanceRequest {
	return InAppPurchasesApiInAppPurchasesUpdateInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InAppPurchaseV2Response
func (a *InAppPurchasesApiService) InAppPurchasesUpdateInstanceExecute(r InAppPurchasesApiInAppPurchasesUpdateInstanceRequest) (*InAppPurchaseV2Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchaseV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesApiService.InAppPurchasesUpdateInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.inAppPurchaseV2UpdateRequest == nil {
		return localVarReturnValue, nil, reportError("inAppPurchaseV2UpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inAppPurchaseV2UpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
