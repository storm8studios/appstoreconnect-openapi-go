/*
App Store Connect API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package appstoreopenapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ProfilesApiService ProfilesApi service
type ProfilesApiService service

type ProfilesApiProfilesBundleIdGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *ProfilesApiService
	id string
	fieldsBundleIds *[]string
}

// the fields to include for returned resources of type bundleIds
func (r ProfilesApiProfilesBundleIdGetToOneRelatedRequest) FieldsBundleIds(fieldsBundleIds []string) ProfilesApiProfilesBundleIdGetToOneRelatedRequest {
	r.fieldsBundleIds = &fieldsBundleIds
	return r
}

func (r ProfilesApiProfilesBundleIdGetToOneRelatedRequest) Execute() (*BundleIdResponse, *http.Response, error) {
	return r.ApiService.ProfilesBundleIdGetToOneRelatedExecute(r)
}

/*
ProfilesBundleIdGetToOneRelated Method for ProfilesBundleIdGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ProfilesApiProfilesBundleIdGetToOneRelatedRequest
*/
func (a *ProfilesApiService) ProfilesBundleIdGetToOneRelated(ctx context.Context, id string) ProfilesApiProfilesBundleIdGetToOneRelatedRequest {
	return ProfilesApiProfilesBundleIdGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return BundleIdResponse
func (a *ProfilesApiService) ProfilesBundleIdGetToOneRelatedExecute(r ProfilesApiProfilesBundleIdGetToOneRelatedRequest) (*BundleIdResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BundleIdResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfilesApiService.ProfilesBundleIdGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/profiles/{id}/bundleId"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsBundleIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[bundleIds]", r.fieldsBundleIds, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfilesApiProfilesCertificatesGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *ProfilesApiService
	id string
	fieldsCertificates *[]string
	limit *int32
}

// the fields to include for returned resources of type certificates
func (r ProfilesApiProfilesCertificatesGetToManyRelatedRequest) FieldsCertificates(fieldsCertificates []string) ProfilesApiProfilesCertificatesGetToManyRelatedRequest {
	r.fieldsCertificates = &fieldsCertificates
	return r
}

// maximum resources per page
func (r ProfilesApiProfilesCertificatesGetToManyRelatedRequest) Limit(limit int32) ProfilesApiProfilesCertificatesGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

func (r ProfilesApiProfilesCertificatesGetToManyRelatedRequest) Execute() (*CertificatesResponse, *http.Response, error) {
	return r.ApiService.ProfilesCertificatesGetToManyRelatedExecute(r)
}

/*
ProfilesCertificatesGetToManyRelated Method for ProfilesCertificatesGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ProfilesApiProfilesCertificatesGetToManyRelatedRequest
*/
func (a *ProfilesApiService) ProfilesCertificatesGetToManyRelated(ctx context.Context, id string) ProfilesApiProfilesCertificatesGetToManyRelatedRequest {
	return ProfilesApiProfilesCertificatesGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CertificatesResponse
func (a *ProfilesApiService) ProfilesCertificatesGetToManyRelatedExecute(r ProfilesApiProfilesCertificatesGetToManyRelatedRequest) (*CertificatesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CertificatesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfilesApiService.ProfilesCertificatesGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/profiles/{id}/certificates"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsCertificates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[certificates]", r.fieldsCertificates, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfilesApiProfilesCreateInstanceRequest struct {
	ctx context.Context
	ApiService *ProfilesApiService
	profileCreateRequest *ProfileCreateRequest
}

// Profile representation
func (r ProfilesApiProfilesCreateInstanceRequest) ProfileCreateRequest(profileCreateRequest ProfileCreateRequest) ProfilesApiProfilesCreateInstanceRequest {
	r.profileCreateRequest = &profileCreateRequest
	return r
}

func (r ProfilesApiProfilesCreateInstanceRequest) Execute() (*ProfileResponse, *http.Response, error) {
	return r.ApiService.ProfilesCreateInstanceExecute(r)
}

/*
ProfilesCreateInstance Method for ProfilesCreateInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfilesApiProfilesCreateInstanceRequest
*/
func (a *ProfilesApiService) ProfilesCreateInstance(ctx context.Context) ProfilesApiProfilesCreateInstanceRequest {
	return ProfilesApiProfilesCreateInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProfileResponse
func (a *ProfilesApiService) ProfilesCreateInstanceExecute(r ProfilesApiProfilesCreateInstanceRequest) (*ProfileResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProfileResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfilesApiService.ProfilesCreateInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/profiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.profileCreateRequest == nil {
		return localVarReturnValue, nil, reportError("profileCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.profileCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfilesApiProfilesDeleteInstanceRequest struct {
	ctx context.Context
	ApiService *ProfilesApiService
	id string
}

func (r ProfilesApiProfilesDeleteInstanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProfilesDeleteInstanceExecute(r)
}

/*
ProfilesDeleteInstance Method for ProfilesDeleteInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ProfilesApiProfilesDeleteInstanceRequest
*/
func (a *ProfilesApiService) ProfilesDeleteInstance(ctx context.Context, id string) ProfilesApiProfilesDeleteInstanceRequest {
	return ProfilesApiProfilesDeleteInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ProfilesApiService) ProfilesDeleteInstanceExecute(r ProfilesApiProfilesDeleteInstanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfilesApiService.ProfilesDeleteInstance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/profiles/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ProfilesApiProfilesDevicesGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *ProfilesApiService
	id string
	fieldsDevices *[]string
	limit *int32
}

// the fields to include for returned resources of type devices
func (r ProfilesApiProfilesDevicesGetToManyRelatedRequest) FieldsDevices(fieldsDevices []string) ProfilesApiProfilesDevicesGetToManyRelatedRequest {
	r.fieldsDevices = &fieldsDevices
	return r
}

// maximum resources per page
func (r ProfilesApiProfilesDevicesGetToManyRelatedRequest) Limit(limit int32) ProfilesApiProfilesDevicesGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

func (r ProfilesApiProfilesDevicesGetToManyRelatedRequest) Execute() (*DevicesResponse, *http.Response, error) {
	return r.ApiService.ProfilesDevicesGetToManyRelatedExecute(r)
}

/*
ProfilesDevicesGetToManyRelated Method for ProfilesDevicesGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ProfilesApiProfilesDevicesGetToManyRelatedRequest
*/
func (a *ProfilesApiService) ProfilesDevicesGetToManyRelated(ctx context.Context, id string) ProfilesApiProfilesDevicesGetToManyRelatedRequest {
	return ProfilesApiProfilesDevicesGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DevicesResponse
func (a *ProfilesApiService) ProfilesDevicesGetToManyRelatedExecute(r ProfilesApiProfilesDevicesGetToManyRelatedRequest) (*DevicesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DevicesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfilesApiService.ProfilesDevicesGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/profiles/{id}/devices"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsDevices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[devices]", r.fieldsDevices, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfilesApiProfilesGetCollectionRequest struct {
	ctx context.Context
	ApiService *ProfilesApiService
	filterName *[]string
	filterProfileState *[]string
	filterProfileType *[]string
	filterId *[]string
	sort *[]string
	fieldsProfiles *[]string
	limit *int32
	include *[]string
	fieldsCertificates *[]string
	fieldsDevices *[]string
	fieldsBundleIds *[]string
	limitCertificates *int32
	limitDevices *int32
}

// filter by attribute &#39;name&#39;
func (r ProfilesApiProfilesGetCollectionRequest) FilterName(filterName []string) ProfilesApiProfilesGetCollectionRequest {
	r.filterName = &filterName
	return r
}

// filter by attribute &#39;profileState&#39;
func (r ProfilesApiProfilesGetCollectionRequest) FilterProfileState(filterProfileState []string) ProfilesApiProfilesGetCollectionRequest {
	r.filterProfileState = &filterProfileState
	return r
}

// filter by attribute &#39;profileType&#39;
func (r ProfilesApiProfilesGetCollectionRequest) FilterProfileType(filterProfileType []string) ProfilesApiProfilesGetCollectionRequest {
	r.filterProfileType = &filterProfileType
	return r
}

// filter by id(s)
func (r ProfilesApiProfilesGetCollectionRequest) FilterId(filterId []string) ProfilesApiProfilesGetCollectionRequest {
	r.filterId = &filterId
	return r
}

// comma-separated list of sort expressions; resources will be sorted as specified
func (r ProfilesApiProfilesGetCollectionRequest) Sort(sort []string) ProfilesApiProfilesGetCollectionRequest {
	r.sort = &sort
	return r
}

// the fields to include for returned resources of type profiles
func (r ProfilesApiProfilesGetCollectionRequest) FieldsProfiles(fieldsProfiles []string) ProfilesApiProfilesGetCollectionRequest {
	r.fieldsProfiles = &fieldsProfiles
	return r
}

// maximum resources per page
func (r ProfilesApiProfilesGetCollectionRequest) Limit(limit int32) ProfilesApiProfilesGetCollectionRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ProfilesApiProfilesGetCollectionRequest) Include(include []string) ProfilesApiProfilesGetCollectionRequest {
	r.include = &include
	return r
}

// the fields to include for returned resources of type certificates
func (r ProfilesApiProfilesGetCollectionRequest) FieldsCertificates(fieldsCertificates []string) ProfilesApiProfilesGetCollectionRequest {
	r.fieldsCertificates = &fieldsCertificates
	return r
}

// the fields to include for returned resources of type devices
func (r ProfilesApiProfilesGetCollectionRequest) FieldsDevices(fieldsDevices []string) ProfilesApiProfilesGetCollectionRequest {
	r.fieldsDevices = &fieldsDevices
	return r
}

// the fields to include for returned resources of type bundleIds
func (r ProfilesApiProfilesGetCollectionRequest) FieldsBundleIds(fieldsBundleIds []string) ProfilesApiProfilesGetCollectionRequest {
	r.fieldsBundleIds = &fieldsBundleIds
	return r
}

// maximum number of related certificates returned (when they are included)
func (r ProfilesApiProfilesGetCollectionRequest) LimitCertificates(limitCertificates int32) ProfilesApiProfilesGetCollectionRequest {
	r.limitCertificates = &limitCertificates
	return r
}

// maximum number of related devices returned (when they are included)
func (r ProfilesApiProfilesGetCollectionRequest) LimitDevices(limitDevices int32) ProfilesApiProfilesGetCollectionRequest {
	r.limitDevices = &limitDevices
	return r
}

func (r ProfilesApiProfilesGetCollectionRequest) Execute() (*ProfilesResponse, *http.Response, error) {
	return r.ApiService.ProfilesGetCollectionExecute(r)
}

/*
ProfilesGetCollection Method for ProfilesGetCollection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfilesApiProfilesGetCollectionRequest
*/
func (a *ProfilesApiService) ProfilesGetCollection(ctx context.Context) ProfilesApiProfilesGetCollectionRequest {
	return ProfilesApiProfilesGetCollectionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProfilesResponse
func (a *ProfilesApiService) ProfilesGetCollectionExecute(r ProfilesApiProfilesGetCollectionRequest) (*ProfilesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProfilesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfilesApiService.ProfilesGetCollection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/profiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[name]", r.filterName, "csv")
	}
	if r.filterProfileState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[profileState]", r.filterProfileState, "csv")
	}
	if r.filterProfileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[profileType]", r.filterProfileType, "csv")
	}
	if r.filterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[id]", r.filterId, "csv")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "csv")
	}
	if r.fieldsProfiles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[profiles]", r.fieldsProfiles, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	if r.fieldsCertificates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[certificates]", r.fieldsCertificates, "csv")
	}
	if r.fieldsDevices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[devices]", r.fieldsDevices, "csv")
	}
	if r.fieldsBundleIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[bundleIds]", r.fieldsBundleIds, "csv")
	}
	if r.limitCertificates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[certificates]", r.limitCertificates, "")
	}
	if r.limitDevices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[devices]", r.limitDevices, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfilesApiProfilesGetInstanceRequest struct {
	ctx context.Context
	ApiService *ProfilesApiService
	id string
	fieldsProfiles *[]string
	include *[]string
	fieldsCertificates *[]string
	fieldsDevices *[]string
	fieldsBundleIds *[]string
	limitCertificates *int32
	limitDevices *int32
}

// the fields to include for returned resources of type profiles
func (r ProfilesApiProfilesGetInstanceRequest) FieldsProfiles(fieldsProfiles []string) ProfilesApiProfilesGetInstanceRequest {
	r.fieldsProfiles = &fieldsProfiles
	return r
}

// comma-separated list of relationships to include
func (r ProfilesApiProfilesGetInstanceRequest) Include(include []string) ProfilesApiProfilesGetInstanceRequest {
	r.include = &include
	return r
}

// the fields to include for returned resources of type certificates
func (r ProfilesApiProfilesGetInstanceRequest) FieldsCertificates(fieldsCertificates []string) ProfilesApiProfilesGetInstanceRequest {
	r.fieldsCertificates = &fieldsCertificates
	return r
}

// the fields to include for returned resources of type devices
func (r ProfilesApiProfilesGetInstanceRequest) FieldsDevices(fieldsDevices []string) ProfilesApiProfilesGetInstanceRequest {
	r.fieldsDevices = &fieldsDevices
	return r
}

// the fields to include for returned resources of type bundleIds
func (r ProfilesApiProfilesGetInstanceRequest) FieldsBundleIds(fieldsBundleIds []string) ProfilesApiProfilesGetInstanceRequest {
	r.fieldsBundleIds = &fieldsBundleIds
	return r
}

// maximum number of related certificates returned (when they are included)
func (r ProfilesApiProfilesGetInstanceRequest) LimitCertificates(limitCertificates int32) ProfilesApiProfilesGetInstanceRequest {
	r.limitCertificates = &limitCertificates
	return r
}

// maximum number of related devices returned (when they are included)
func (r ProfilesApiProfilesGetInstanceRequest) LimitDevices(limitDevices int32) ProfilesApiProfilesGetInstanceRequest {
	r.limitDevices = &limitDevices
	return r
}

func (r ProfilesApiProfilesGetInstanceRequest) Execute() (*ProfileResponse, *http.Response, error) {
	return r.ApiService.ProfilesGetInstanceExecute(r)
}

/*
ProfilesGetInstance Method for ProfilesGetInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ProfilesApiProfilesGetInstanceRequest
*/
func (a *ProfilesApiService) ProfilesGetInstance(ctx context.Context, id string) ProfilesApiProfilesGetInstanceRequest {
	return ProfilesApiProfilesGetInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ProfileResponse
func (a *ProfilesApiService) ProfilesGetInstanceExecute(r ProfilesApiProfilesGetInstanceRequest) (*ProfileResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProfileResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfilesApiService.ProfilesGetInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/profiles/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsProfiles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[profiles]", r.fieldsProfiles, "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	if r.fieldsCertificates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[certificates]", r.fieldsCertificates, "csv")
	}
	if r.fieldsDevices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[devices]", r.fieldsDevices, "csv")
	}
	if r.fieldsBundleIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[bundleIds]", r.fieldsBundleIds, "csv")
	}
	if r.limitCertificates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[certificates]", r.limitCertificates, "")
	}
	if r.limitDevices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[devices]", r.limitDevices, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
