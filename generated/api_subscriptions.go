/*
App Store Connect API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package appstoreopenapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// SubscriptionsApiService SubscriptionsApi service
type SubscriptionsApiService service

type SubscriptionsApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *SubscriptionsApiService
	id string
	fieldsSubscriptionAppStoreReviewScreenshots *[]string
	fieldsSubscriptions *[]string
	include *[]string
}

// the fields to include for returned resources of type subscriptionAppStoreReviewScreenshots
func (r SubscriptionsApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest) FieldsSubscriptionAppStoreReviewScreenshots(fieldsSubscriptionAppStoreReviewScreenshots []string) SubscriptionsApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest {
	r.fieldsSubscriptionAppStoreReviewScreenshots = &fieldsSubscriptionAppStoreReviewScreenshots
	return r
}

// the fields to include for returned resources of type subscriptions
func (r SubscriptionsApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest) FieldsSubscriptions(fieldsSubscriptions []string) SubscriptionsApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// comma-separated list of relationships to include
func (r SubscriptionsApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest) Include(include []string) SubscriptionsApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r SubscriptionsApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest) Execute() (*SubscriptionAppStoreReviewScreenshotResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsAppStoreReviewScreenshotGetToOneRelatedExecute(r)
}

/*
SubscriptionsAppStoreReviewScreenshotGetToOneRelated Method for SubscriptionsAppStoreReviewScreenshotGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return SubscriptionsApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest
*/
func (a *SubscriptionsApiService) SubscriptionsAppStoreReviewScreenshotGetToOneRelated(ctx context.Context, id string) SubscriptionsApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest {
	return SubscriptionsApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SubscriptionAppStoreReviewScreenshotResponse
func (a *SubscriptionsApiService) SubscriptionsAppStoreReviewScreenshotGetToOneRelatedExecute(r SubscriptionsApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest) (*SubscriptionAppStoreReviewScreenshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionAppStoreReviewScreenshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsAppStoreReviewScreenshotGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/appStoreReviewScreenshot"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsSubscriptionAppStoreReviewScreenshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionAppStoreReviewScreenshots]", r.fieldsSubscriptionAppStoreReviewScreenshots, "csv")
	}
	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionsApiSubscriptionsCreateInstanceRequest struct {
	ctx context.Context
	ApiService *SubscriptionsApiService
	subscriptionCreateRequest *SubscriptionCreateRequest
}

// Subscription representation
func (r SubscriptionsApiSubscriptionsCreateInstanceRequest) SubscriptionCreateRequest(subscriptionCreateRequest SubscriptionCreateRequest) SubscriptionsApiSubscriptionsCreateInstanceRequest {
	r.subscriptionCreateRequest = &subscriptionCreateRequest
	return r
}

func (r SubscriptionsApiSubscriptionsCreateInstanceRequest) Execute() (*SubscriptionResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsCreateInstanceExecute(r)
}

/*
SubscriptionsCreateInstance Method for SubscriptionsCreateInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionsApiSubscriptionsCreateInstanceRequest
*/
func (a *SubscriptionsApiService) SubscriptionsCreateInstance(ctx context.Context) SubscriptionsApiSubscriptionsCreateInstanceRequest {
	return SubscriptionsApiSubscriptionsCreateInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubscriptionResponse
func (a *SubscriptionsApiService) SubscriptionsCreateInstanceExecute(r SubscriptionsApiSubscriptionsCreateInstanceRequest) (*SubscriptionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsCreateInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subscriptionCreateRequest == nil {
		return localVarReturnValue, nil, reportError("subscriptionCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.subscriptionCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionsApiSubscriptionsDeleteInstanceRequest struct {
	ctx context.Context
	ApiService *SubscriptionsApiService
	id string
}

func (r SubscriptionsApiSubscriptionsDeleteInstanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.SubscriptionsDeleteInstanceExecute(r)
}

/*
SubscriptionsDeleteInstance Method for SubscriptionsDeleteInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return SubscriptionsApiSubscriptionsDeleteInstanceRequest
*/
func (a *SubscriptionsApiService) SubscriptionsDeleteInstance(ctx context.Context, id string) SubscriptionsApiSubscriptionsDeleteInstanceRequest {
	return SubscriptionsApiSubscriptionsDeleteInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *SubscriptionsApiService) SubscriptionsDeleteInstanceExecute(r SubscriptionsApiSubscriptionsDeleteInstanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsDeleteInstance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SubscriptionsApiSubscriptionsGetInstanceRequest struct {
	ctx context.Context
	ApiService *SubscriptionsApiService
	id string
	fieldsSubscriptions *[]string
	include *[]string
	fieldsPromotedPurchases *[]string
	fieldsSubscriptionPricePoints *[]string
	fieldsSubscriptionPromotionalOffers *[]string
	fieldsSubscriptionOfferCodes *[]string
	fieldsSubscriptionAppStoreReviewScreenshots *[]string
	fieldsSubscriptionPrices *[]string
	fieldsSubscriptionIntroductoryOffers *[]string
	fieldsSubscriptionLocalizations *[]string
	limitIntroductoryOffers *int32
	limitOfferCodes *int32
	limitPrices *int32
	limitPromotionalOffers *int32
	limitSubscriptionLocalizations *int32
}

// the fields to include for returned resources of type subscriptions
func (r SubscriptionsApiSubscriptionsGetInstanceRequest) FieldsSubscriptions(fieldsSubscriptions []string) SubscriptionsApiSubscriptionsGetInstanceRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// comma-separated list of relationships to include
func (r SubscriptionsApiSubscriptionsGetInstanceRequest) Include(include []string) SubscriptionsApiSubscriptionsGetInstanceRequest {
	r.include = &include
	return r
}

// the fields to include for returned resources of type promotedPurchases
func (r SubscriptionsApiSubscriptionsGetInstanceRequest) FieldsPromotedPurchases(fieldsPromotedPurchases []string) SubscriptionsApiSubscriptionsGetInstanceRequest {
	r.fieldsPromotedPurchases = &fieldsPromotedPurchases
	return r
}

// the fields to include for returned resources of type subscriptionPricePoints
func (r SubscriptionsApiSubscriptionsGetInstanceRequest) FieldsSubscriptionPricePoints(fieldsSubscriptionPricePoints []string) SubscriptionsApiSubscriptionsGetInstanceRequest {
	r.fieldsSubscriptionPricePoints = &fieldsSubscriptionPricePoints
	return r
}

// the fields to include for returned resources of type subscriptionPromotionalOffers
func (r SubscriptionsApiSubscriptionsGetInstanceRequest) FieldsSubscriptionPromotionalOffers(fieldsSubscriptionPromotionalOffers []string) SubscriptionsApiSubscriptionsGetInstanceRequest {
	r.fieldsSubscriptionPromotionalOffers = &fieldsSubscriptionPromotionalOffers
	return r
}

// the fields to include for returned resources of type subscriptionOfferCodes
func (r SubscriptionsApiSubscriptionsGetInstanceRequest) FieldsSubscriptionOfferCodes(fieldsSubscriptionOfferCodes []string) SubscriptionsApiSubscriptionsGetInstanceRequest {
	r.fieldsSubscriptionOfferCodes = &fieldsSubscriptionOfferCodes
	return r
}

// the fields to include for returned resources of type subscriptionAppStoreReviewScreenshots
func (r SubscriptionsApiSubscriptionsGetInstanceRequest) FieldsSubscriptionAppStoreReviewScreenshots(fieldsSubscriptionAppStoreReviewScreenshots []string) SubscriptionsApiSubscriptionsGetInstanceRequest {
	r.fieldsSubscriptionAppStoreReviewScreenshots = &fieldsSubscriptionAppStoreReviewScreenshots
	return r
}

// the fields to include for returned resources of type subscriptionPrices
func (r SubscriptionsApiSubscriptionsGetInstanceRequest) FieldsSubscriptionPrices(fieldsSubscriptionPrices []string) SubscriptionsApiSubscriptionsGetInstanceRequest {
	r.fieldsSubscriptionPrices = &fieldsSubscriptionPrices
	return r
}

// the fields to include for returned resources of type subscriptionIntroductoryOffers
func (r SubscriptionsApiSubscriptionsGetInstanceRequest) FieldsSubscriptionIntroductoryOffers(fieldsSubscriptionIntroductoryOffers []string) SubscriptionsApiSubscriptionsGetInstanceRequest {
	r.fieldsSubscriptionIntroductoryOffers = &fieldsSubscriptionIntroductoryOffers
	return r
}

// the fields to include for returned resources of type subscriptionLocalizations
func (r SubscriptionsApiSubscriptionsGetInstanceRequest) FieldsSubscriptionLocalizations(fieldsSubscriptionLocalizations []string) SubscriptionsApiSubscriptionsGetInstanceRequest {
	r.fieldsSubscriptionLocalizations = &fieldsSubscriptionLocalizations
	return r
}

// maximum number of related introductoryOffers returned (when they are included)
func (r SubscriptionsApiSubscriptionsGetInstanceRequest) LimitIntroductoryOffers(limitIntroductoryOffers int32) SubscriptionsApiSubscriptionsGetInstanceRequest {
	r.limitIntroductoryOffers = &limitIntroductoryOffers
	return r
}

// maximum number of related offerCodes returned (when they are included)
func (r SubscriptionsApiSubscriptionsGetInstanceRequest) LimitOfferCodes(limitOfferCodes int32) SubscriptionsApiSubscriptionsGetInstanceRequest {
	r.limitOfferCodes = &limitOfferCodes
	return r
}

// maximum number of related prices returned (when they are included)
func (r SubscriptionsApiSubscriptionsGetInstanceRequest) LimitPrices(limitPrices int32) SubscriptionsApiSubscriptionsGetInstanceRequest {
	r.limitPrices = &limitPrices
	return r
}

// maximum number of related promotionalOffers returned (when they are included)
func (r SubscriptionsApiSubscriptionsGetInstanceRequest) LimitPromotionalOffers(limitPromotionalOffers int32) SubscriptionsApiSubscriptionsGetInstanceRequest {
	r.limitPromotionalOffers = &limitPromotionalOffers
	return r
}

// maximum number of related subscriptionLocalizations returned (when they are included)
func (r SubscriptionsApiSubscriptionsGetInstanceRequest) LimitSubscriptionLocalizations(limitSubscriptionLocalizations int32) SubscriptionsApiSubscriptionsGetInstanceRequest {
	r.limitSubscriptionLocalizations = &limitSubscriptionLocalizations
	return r
}

func (r SubscriptionsApiSubscriptionsGetInstanceRequest) Execute() (*SubscriptionResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsGetInstanceExecute(r)
}

/*
SubscriptionsGetInstance Method for SubscriptionsGetInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return SubscriptionsApiSubscriptionsGetInstanceRequest
*/
func (a *SubscriptionsApiService) SubscriptionsGetInstance(ctx context.Context, id string) SubscriptionsApiSubscriptionsGetInstanceRequest {
	return SubscriptionsApiSubscriptionsGetInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SubscriptionResponse
func (a *SubscriptionsApiService) SubscriptionsGetInstanceExecute(r SubscriptionsApiSubscriptionsGetInstanceRequest) (*SubscriptionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsGetInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	if r.fieldsPromotedPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchases]", r.fieldsPromotedPurchases, "csv")
	}
	if r.fieldsSubscriptionPricePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionPricePoints]", r.fieldsSubscriptionPricePoints, "csv")
	}
	if r.fieldsSubscriptionPromotionalOffers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionPromotionalOffers]", r.fieldsSubscriptionPromotionalOffers, "csv")
	}
	if r.fieldsSubscriptionOfferCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionOfferCodes]", r.fieldsSubscriptionOfferCodes, "csv")
	}
	if r.fieldsSubscriptionAppStoreReviewScreenshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionAppStoreReviewScreenshots]", r.fieldsSubscriptionAppStoreReviewScreenshots, "csv")
	}
	if r.fieldsSubscriptionPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionPrices]", r.fieldsSubscriptionPrices, "csv")
	}
	if r.fieldsSubscriptionIntroductoryOffers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionIntroductoryOffers]", r.fieldsSubscriptionIntroductoryOffers, "csv")
	}
	if r.fieldsSubscriptionLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionLocalizations]", r.fieldsSubscriptionLocalizations, "csv")
	}
	if r.limitIntroductoryOffers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[introductoryOffers]", r.limitIntroductoryOffers, "")
	}
	if r.limitOfferCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[offerCodes]", r.limitOfferCodes, "")
	}
	if r.limitPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[prices]", r.limitPrices, "")
	}
	if r.limitPromotionalOffers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[promotionalOffers]", r.limitPromotionalOffers, "")
	}
	if r.limitSubscriptionLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subscriptionLocalizations]", r.limitSubscriptionLocalizations, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionsApiSubscriptionsIntroductoryOffersDeleteToManyRelationshipRequest struct {
	ctx context.Context
	ApiService *SubscriptionsApiService
	id string
	subscriptionIntroductoryOffersLinkagesRequest *SubscriptionIntroductoryOffersLinkagesRequest
}

// List of related linkages
func (r SubscriptionsApiSubscriptionsIntroductoryOffersDeleteToManyRelationshipRequest) SubscriptionIntroductoryOffersLinkagesRequest(subscriptionIntroductoryOffersLinkagesRequest SubscriptionIntroductoryOffersLinkagesRequest) SubscriptionsApiSubscriptionsIntroductoryOffersDeleteToManyRelationshipRequest {
	r.subscriptionIntroductoryOffersLinkagesRequest = &subscriptionIntroductoryOffersLinkagesRequest
	return r
}

func (r SubscriptionsApiSubscriptionsIntroductoryOffersDeleteToManyRelationshipRequest) Execute() (*http.Response, error) {
	return r.ApiService.SubscriptionsIntroductoryOffersDeleteToManyRelationshipExecute(r)
}

/*
SubscriptionsIntroductoryOffersDeleteToManyRelationship Method for SubscriptionsIntroductoryOffersDeleteToManyRelationship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return SubscriptionsApiSubscriptionsIntroductoryOffersDeleteToManyRelationshipRequest
*/
func (a *SubscriptionsApiService) SubscriptionsIntroductoryOffersDeleteToManyRelationship(ctx context.Context, id string) SubscriptionsApiSubscriptionsIntroductoryOffersDeleteToManyRelationshipRequest {
	return SubscriptionsApiSubscriptionsIntroductoryOffersDeleteToManyRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *SubscriptionsApiService) SubscriptionsIntroductoryOffersDeleteToManyRelationshipExecute(r SubscriptionsApiSubscriptionsIntroductoryOffersDeleteToManyRelationshipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsIntroductoryOffersDeleteToManyRelationship")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/relationships/introductoryOffers"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subscriptionIntroductoryOffersLinkagesRequest == nil {
		return nil, reportError("subscriptionIntroductoryOffersLinkagesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.subscriptionIntroductoryOffersLinkagesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SubscriptionsApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *SubscriptionsApiService
	id string
	filterTerritory *[]string
	fieldsSubscriptionPricePoints *[]string
	fieldsSubscriptions *[]string
	fieldsSubscriptionIntroductoryOffers *[]string
	fieldsTerritories *[]string
	limit *int32
	include *[]string
}

// filter by id(s) of related &#39;territory&#39;
func (r SubscriptionsApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest) FilterTerritory(filterTerritory []string) SubscriptionsApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest {
	r.filterTerritory = &filterTerritory
	return r
}

// the fields to include for returned resources of type subscriptionPricePoints
func (r SubscriptionsApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest) FieldsSubscriptionPricePoints(fieldsSubscriptionPricePoints []string) SubscriptionsApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest {
	r.fieldsSubscriptionPricePoints = &fieldsSubscriptionPricePoints
	return r
}

// the fields to include for returned resources of type subscriptions
func (r SubscriptionsApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest) FieldsSubscriptions(fieldsSubscriptions []string) SubscriptionsApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// the fields to include for returned resources of type subscriptionIntroductoryOffers
func (r SubscriptionsApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest) FieldsSubscriptionIntroductoryOffers(fieldsSubscriptionIntroductoryOffers []string) SubscriptionsApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest {
	r.fieldsSubscriptionIntroductoryOffers = &fieldsSubscriptionIntroductoryOffers
	return r
}

// the fields to include for returned resources of type territories
func (r SubscriptionsApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest) FieldsTerritories(fieldsTerritories []string) SubscriptionsApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// maximum resources per page
func (r SubscriptionsApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest) Limit(limit int32) SubscriptionsApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r SubscriptionsApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest) Include(include []string) SubscriptionsApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r SubscriptionsApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest) Execute() (*SubscriptionIntroductoryOffersResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsIntroductoryOffersGetToManyRelatedExecute(r)
}

/*
SubscriptionsIntroductoryOffersGetToManyRelated Method for SubscriptionsIntroductoryOffersGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return SubscriptionsApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest
*/
func (a *SubscriptionsApiService) SubscriptionsIntroductoryOffersGetToManyRelated(ctx context.Context, id string) SubscriptionsApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest {
	return SubscriptionsApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SubscriptionIntroductoryOffersResponse
func (a *SubscriptionsApiService) SubscriptionsIntroductoryOffersGetToManyRelatedExecute(r SubscriptionsApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest) (*SubscriptionIntroductoryOffersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionIntroductoryOffersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsIntroductoryOffersGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/introductoryOffers"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterTerritory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[territory]", r.filterTerritory, "csv")
	}
	if r.fieldsSubscriptionPricePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionPricePoints]", r.fieldsSubscriptionPricePoints, "csv")
	}
	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "csv")
	}
	if r.fieldsSubscriptionIntroductoryOffers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionIntroductoryOffers]", r.fieldsSubscriptionIntroductoryOffers, "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionsApiSubscriptionsIntroductoryOffersGetToManyRelationshipRequest struct {
	ctx context.Context
	ApiService *SubscriptionsApiService
	id string
	limit *int32
}

// maximum resources per page
func (r SubscriptionsApiSubscriptionsIntroductoryOffersGetToManyRelationshipRequest) Limit(limit int32) SubscriptionsApiSubscriptionsIntroductoryOffersGetToManyRelationshipRequest {
	r.limit = &limit
	return r
}

func (r SubscriptionsApiSubscriptionsIntroductoryOffersGetToManyRelationshipRequest) Execute() (*SubscriptionIntroductoryOffersLinkagesResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsIntroductoryOffersGetToManyRelationshipExecute(r)
}

/*
SubscriptionsIntroductoryOffersGetToManyRelationship Method for SubscriptionsIntroductoryOffersGetToManyRelationship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return SubscriptionsApiSubscriptionsIntroductoryOffersGetToManyRelationshipRequest
*/
func (a *SubscriptionsApiService) SubscriptionsIntroductoryOffersGetToManyRelationship(ctx context.Context, id string) SubscriptionsApiSubscriptionsIntroductoryOffersGetToManyRelationshipRequest {
	return SubscriptionsApiSubscriptionsIntroductoryOffersGetToManyRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SubscriptionIntroductoryOffersLinkagesResponse
func (a *SubscriptionsApiService) SubscriptionsIntroductoryOffersGetToManyRelationshipExecute(r SubscriptionsApiSubscriptionsIntroductoryOffersGetToManyRelationshipRequest) (*SubscriptionIntroductoryOffersLinkagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionIntroductoryOffersLinkagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsIntroductoryOffersGetToManyRelationship")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/relationships/introductoryOffers"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionsApiSubscriptionsOfferCodesGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *SubscriptionsApiService
	id string
	filterTerritory *[]string
	fieldsSubscriptionOfferCodeCustomCodes *[]string
	fieldsSubscriptionOfferCodes *[]string
	fieldsSubscriptionOfferCodeOneTimeUseCodes *[]string
	fieldsSubscriptions *[]string
	fieldsSubscriptionOfferCodePrices *[]string
	limit *int32
	limitOneTimeUseCodes *int32
	limitCustomCodes *int32
	limitPrices *int32
	include *[]string
}

// filter by territory
func (r SubscriptionsApiSubscriptionsOfferCodesGetToManyRelatedRequest) FilterTerritory(filterTerritory []string) SubscriptionsApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.filterTerritory = &filterTerritory
	return r
}

// the fields to include for returned resources of type subscriptionOfferCodeCustomCodes
func (r SubscriptionsApiSubscriptionsOfferCodesGetToManyRelatedRequest) FieldsSubscriptionOfferCodeCustomCodes(fieldsSubscriptionOfferCodeCustomCodes []string) SubscriptionsApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.fieldsSubscriptionOfferCodeCustomCodes = &fieldsSubscriptionOfferCodeCustomCodes
	return r
}

// the fields to include for returned resources of type subscriptionOfferCodes
func (r SubscriptionsApiSubscriptionsOfferCodesGetToManyRelatedRequest) FieldsSubscriptionOfferCodes(fieldsSubscriptionOfferCodes []string) SubscriptionsApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.fieldsSubscriptionOfferCodes = &fieldsSubscriptionOfferCodes
	return r
}

// the fields to include for returned resources of type subscriptionOfferCodeOneTimeUseCodes
func (r SubscriptionsApiSubscriptionsOfferCodesGetToManyRelatedRequest) FieldsSubscriptionOfferCodeOneTimeUseCodes(fieldsSubscriptionOfferCodeOneTimeUseCodes []string) SubscriptionsApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.fieldsSubscriptionOfferCodeOneTimeUseCodes = &fieldsSubscriptionOfferCodeOneTimeUseCodes
	return r
}

// the fields to include for returned resources of type subscriptions
func (r SubscriptionsApiSubscriptionsOfferCodesGetToManyRelatedRequest) FieldsSubscriptions(fieldsSubscriptions []string) SubscriptionsApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// the fields to include for returned resources of type subscriptionOfferCodePrices
func (r SubscriptionsApiSubscriptionsOfferCodesGetToManyRelatedRequest) FieldsSubscriptionOfferCodePrices(fieldsSubscriptionOfferCodePrices []string) SubscriptionsApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.fieldsSubscriptionOfferCodePrices = &fieldsSubscriptionOfferCodePrices
	return r
}

// maximum resources per page
func (r SubscriptionsApiSubscriptionsOfferCodesGetToManyRelatedRequest) Limit(limit int32) SubscriptionsApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// maximum number of related oneTimeUseCodes returned (when they are included)
func (r SubscriptionsApiSubscriptionsOfferCodesGetToManyRelatedRequest) LimitOneTimeUseCodes(limitOneTimeUseCodes int32) SubscriptionsApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.limitOneTimeUseCodes = &limitOneTimeUseCodes
	return r
}

// maximum number of related customCodes returned (when they are included)
func (r SubscriptionsApiSubscriptionsOfferCodesGetToManyRelatedRequest) LimitCustomCodes(limitCustomCodes int32) SubscriptionsApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.limitCustomCodes = &limitCustomCodes
	return r
}

// maximum number of related prices returned (when they are included)
func (r SubscriptionsApiSubscriptionsOfferCodesGetToManyRelatedRequest) LimitPrices(limitPrices int32) SubscriptionsApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.limitPrices = &limitPrices
	return r
}

// comma-separated list of relationships to include
func (r SubscriptionsApiSubscriptionsOfferCodesGetToManyRelatedRequest) Include(include []string) SubscriptionsApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r SubscriptionsApiSubscriptionsOfferCodesGetToManyRelatedRequest) Execute() (*SubscriptionOfferCodesResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsOfferCodesGetToManyRelatedExecute(r)
}

/*
SubscriptionsOfferCodesGetToManyRelated Method for SubscriptionsOfferCodesGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return SubscriptionsApiSubscriptionsOfferCodesGetToManyRelatedRequest
*/
func (a *SubscriptionsApiService) SubscriptionsOfferCodesGetToManyRelated(ctx context.Context, id string) SubscriptionsApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	return SubscriptionsApiSubscriptionsOfferCodesGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SubscriptionOfferCodesResponse
func (a *SubscriptionsApiService) SubscriptionsOfferCodesGetToManyRelatedExecute(r SubscriptionsApiSubscriptionsOfferCodesGetToManyRelatedRequest) (*SubscriptionOfferCodesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionOfferCodesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsOfferCodesGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/offerCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterTerritory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[territory]", r.filterTerritory, "csv")
	}
	if r.fieldsSubscriptionOfferCodeCustomCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionOfferCodeCustomCodes]", r.fieldsSubscriptionOfferCodeCustomCodes, "csv")
	}
	if r.fieldsSubscriptionOfferCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionOfferCodes]", r.fieldsSubscriptionOfferCodes, "csv")
	}
	if r.fieldsSubscriptionOfferCodeOneTimeUseCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionOfferCodeOneTimeUseCodes]", r.fieldsSubscriptionOfferCodeOneTimeUseCodes, "csv")
	}
	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "csv")
	}
	if r.fieldsSubscriptionOfferCodePrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionOfferCodePrices]", r.fieldsSubscriptionOfferCodePrices, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.limitOneTimeUseCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[oneTimeUseCodes]", r.limitOneTimeUseCodes, "")
	}
	if r.limitCustomCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[customCodes]", r.limitCustomCodes, "")
	}
	if r.limitPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[prices]", r.limitPrices, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionsApiSubscriptionsPricePointsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *SubscriptionsApiService
	id string
	filterTerritory *[]string
	fieldsSubscriptionPricePoints *[]string
	fieldsTerritories *[]string
	limit *int32
	include *[]string
}

// filter by id(s) of related &#39;territory&#39;
func (r SubscriptionsApiSubscriptionsPricePointsGetToManyRelatedRequest) FilterTerritory(filterTerritory []string) SubscriptionsApiSubscriptionsPricePointsGetToManyRelatedRequest {
	r.filterTerritory = &filterTerritory
	return r
}

// the fields to include for returned resources of type subscriptionPricePoints
func (r SubscriptionsApiSubscriptionsPricePointsGetToManyRelatedRequest) FieldsSubscriptionPricePoints(fieldsSubscriptionPricePoints []string) SubscriptionsApiSubscriptionsPricePointsGetToManyRelatedRequest {
	r.fieldsSubscriptionPricePoints = &fieldsSubscriptionPricePoints
	return r
}

// the fields to include for returned resources of type territories
func (r SubscriptionsApiSubscriptionsPricePointsGetToManyRelatedRequest) FieldsTerritories(fieldsTerritories []string) SubscriptionsApiSubscriptionsPricePointsGetToManyRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// maximum resources per page
func (r SubscriptionsApiSubscriptionsPricePointsGetToManyRelatedRequest) Limit(limit int32) SubscriptionsApiSubscriptionsPricePointsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r SubscriptionsApiSubscriptionsPricePointsGetToManyRelatedRequest) Include(include []string) SubscriptionsApiSubscriptionsPricePointsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r SubscriptionsApiSubscriptionsPricePointsGetToManyRelatedRequest) Execute() (*SubscriptionPricePointsResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsPricePointsGetToManyRelatedExecute(r)
}

/*
SubscriptionsPricePointsGetToManyRelated Method for SubscriptionsPricePointsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return SubscriptionsApiSubscriptionsPricePointsGetToManyRelatedRequest
*/
func (a *SubscriptionsApiService) SubscriptionsPricePointsGetToManyRelated(ctx context.Context, id string) SubscriptionsApiSubscriptionsPricePointsGetToManyRelatedRequest {
	return SubscriptionsApiSubscriptionsPricePointsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SubscriptionPricePointsResponse
func (a *SubscriptionsApiService) SubscriptionsPricePointsGetToManyRelatedExecute(r SubscriptionsApiSubscriptionsPricePointsGetToManyRelatedRequest) (*SubscriptionPricePointsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionPricePointsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsPricePointsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/pricePoints"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterTerritory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[territory]", r.filterTerritory, "csv")
	}
	if r.fieldsSubscriptionPricePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionPricePoints]", r.fieldsSubscriptionPricePoints, "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionsApiSubscriptionsPricesDeleteToManyRelationshipRequest struct {
	ctx context.Context
	ApiService *SubscriptionsApiService
	id string
	subscriptionPricesLinkagesRequest *SubscriptionPricesLinkagesRequest
}

// List of related linkages
func (r SubscriptionsApiSubscriptionsPricesDeleteToManyRelationshipRequest) SubscriptionPricesLinkagesRequest(subscriptionPricesLinkagesRequest SubscriptionPricesLinkagesRequest) SubscriptionsApiSubscriptionsPricesDeleteToManyRelationshipRequest {
	r.subscriptionPricesLinkagesRequest = &subscriptionPricesLinkagesRequest
	return r
}

func (r SubscriptionsApiSubscriptionsPricesDeleteToManyRelationshipRequest) Execute() (*http.Response, error) {
	return r.ApiService.SubscriptionsPricesDeleteToManyRelationshipExecute(r)
}

/*
SubscriptionsPricesDeleteToManyRelationship Method for SubscriptionsPricesDeleteToManyRelationship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return SubscriptionsApiSubscriptionsPricesDeleteToManyRelationshipRequest
*/
func (a *SubscriptionsApiService) SubscriptionsPricesDeleteToManyRelationship(ctx context.Context, id string) SubscriptionsApiSubscriptionsPricesDeleteToManyRelationshipRequest {
	return SubscriptionsApiSubscriptionsPricesDeleteToManyRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *SubscriptionsApiService) SubscriptionsPricesDeleteToManyRelationshipExecute(r SubscriptionsApiSubscriptionsPricesDeleteToManyRelationshipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsPricesDeleteToManyRelationship")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/relationships/prices"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subscriptionPricesLinkagesRequest == nil {
		return nil, reportError("subscriptionPricesLinkagesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.subscriptionPricesLinkagesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SubscriptionsApiSubscriptionsPricesGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *SubscriptionsApiService
	id string
	filterSubscriptionPricePoint *[]string
	filterTerritory *[]string
	fieldsSubscriptionPricePoints *[]string
	fieldsSubscriptionPrices *[]string
	fieldsTerritories *[]string
	limit *int32
	include *[]string
}

// filter by id(s) of related &#39;subscriptionPricePoint&#39;
func (r SubscriptionsApiSubscriptionsPricesGetToManyRelatedRequest) FilterSubscriptionPricePoint(filterSubscriptionPricePoint []string) SubscriptionsApiSubscriptionsPricesGetToManyRelatedRequest {
	r.filterSubscriptionPricePoint = &filterSubscriptionPricePoint
	return r
}

// filter by id(s) of related &#39;territory&#39;
func (r SubscriptionsApiSubscriptionsPricesGetToManyRelatedRequest) FilterTerritory(filterTerritory []string) SubscriptionsApiSubscriptionsPricesGetToManyRelatedRequest {
	r.filterTerritory = &filterTerritory
	return r
}

// the fields to include for returned resources of type subscriptionPricePoints
func (r SubscriptionsApiSubscriptionsPricesGetToManyRelatedRequest) FieldsSubscriptionPricePoints(fieldsSubscriptionPricePoints []string) SubscriptionsApiSubscriptionsPricesGetToManyRelatedRequest {
	r.fieldsSubscriptionPricePoints = &fieldsSubscriptionPricePoints
	return r
}

// the fields to include for returned resources of type subscriptionPrices
func (r SubscriptionsApiSubscriptionsPricesGetToManyRelatedRequest) FieldsSubscriptionPrices(fieldsSubscriptionPrices []string) SubscriptionsApiSubscriptionsPricesGetToManyRelatedRequest {
	r.fieldsSubscriptionPrices = &fieldsSubscriptionPrices
	return r
}

// the fields to include for returned resources of type territories
func (r SubscriptionsApiSubscriptionsPricesGetToManyRelatedRequest) FieldsTerritories(fieldsTerritories []string) SubscriptionsApiSubscriptionsPricesGetToManyRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// maximum resources per page
func (r SubscriptionsApiSubscriptionsPricesGetToManyRelatedRequest) Limit(limit int32) SubscriptionsApiSubscriptionsPricesGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r SubscriptionsApiSubscriptionsPricesGetToManyRelatedRequest) Include(include []string) SubscriptionsApiSubscriptionsPricesGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r SubscriptionsApiSubscriptionsPricesGetToManyRelatedRequest) Execute() (*SubscriptionPricesResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsPricesGetToManyRelatedExecute(r)
}

/*
SubscriptionsPricesGetToManyRelated Method for SubscriptionsPricesGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return SubscriptionsApiSubscriptionsPricesGetToManyRelatedRequest
*/
func (a *SubscriptionsApiService) SubscriptionsPricesGetToManyRelated(ctx context.Context, id string) SubscriptionsApiSubscriptionsPricesGetToManyRelatedRequest {
	return SubscriptionsApiSubscriptionsPricesGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SubscriptionPricesResponse
func (a *SubscriptionsApiService) SubscriptionsPricesGetToManyRelatedExecute(r SubscriptionsApiSubscriptionsPricesGetToManyRelatedRequest) (*SubscriptionPricesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionPricesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsPricesGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/prices"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterSubscriptionPricePoint != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[subscriptionPricePoint]", r.filterSubscriptionPricePoint, "csv")
	}
	if r.filterTerritory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[territory]", r.filterTerritory, "csv")
	}
	if r.fieldsSubscriptionPricePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionPricePoints]", r.fieldsSubscriptionPricePoints, "csv")
	}
	if r.fieldsSubscriptionPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionPrices]", r.fieldsSubscriptionPrices, "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionsApiSubscriptionsPricesGetToManyRelationshipRequest struct {
	ctx context.Context
	ApiService *SubscriptionsApiService
	id string
	limit *int32
}

// maximum resources per page
func (r SubscriptionsApiSubscriptionsPricesGetToManyRelationshipRequest) Limit(limit int32) SubscriptionsApiSubscriptionsPricesGetToManyRelationshipRequest {
	r.limit = &limit
	return r
}

func (r SubscriptionsApiSubscriptionsPricesGetToManyRelationshipRequest) Execute() (*SubscriptionPricesLinkagesResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsPricesGetToManyRelationshipExecute(r)
}

/*
SubscriptionsPricesGetToManyRelationship Method for SubscriptionsPricesGetToManyRelationship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return SubscriptionsApiSubscriptionsPricesGetToManyRelationshipRequest
*/
func (a *SubscriptionsApiService) SubscriptionsPricesGetToManyRelationship(ctx context.Context, id string) SubscriptionsApiSubscriptionsPricesGetToManyRelationshipRequest {
	return SubscriptionsApiSubscriptionsPricesGetToManyRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SubscriptionPricesLinkagesResponse
func (a *SubscriptionsApiService) SubscriptionsPricesGetToManyRelationshipExecute(r SubscriptionsApiSubscriptionsPricesGetToManyRelationshipRequest) (*SubscriptionPricesLinkagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionPricesLinkagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsPricesGetToManyRelationship")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/relationships/prices"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionsApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *SubscriptionsApiService
	id string
	fieldsPromotedPurchases *[]string
	fieldsSubscriptions *[]string
	fieldsInAppPurchases *[]string
	fieldsPromotedPurchaseImages *[]string
	limitPromotionImages *int32
	include *[]string
}

// the fields to include for returned resources of type promotedPurchases
func (r SubscriptionsApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest) FieldsPromotedPurchases(fieldsPromotedPurchases []string) SubscriptionsApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest {
	r.fieldsPromotedPurchases = &fieldsPromotedPurchases
	return r
}

// the fields to include for returned resources of type subscriptions
func (r SubscriptionsApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest) FieldsSubscriptions(fieldsSubscriptions []string) SubscriptionsApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r SubscriptionsApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) SubscriptionsApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// the fields to include for returned resources of type promotedPurchaseImages
func (r SubscriptionsApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest) FieldsPromotedPurchaseImages(fieldsPromotedPurchaseImages []string) SubscriptionsApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest {
	r.fieldsPromotedPurchaseImages = &fieldsPromotedPurchaseImages
	return r
}

// maximum number of related promotionImages returned (when they are included)
func (r SubscriptionsApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest) LimitPromotionImages(limitPromotionImages int32) SubscriptionsApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest {
	r.limitPromotionImages = &limitPromotionImages
	return r
}

// comma-separated list of relationships to include
func (r SubscriptionsApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest) Include(include []string) SubscriptionsApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r SubscriptionsApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest) Execute() (*PromotedPurchaseResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsPromotedPurchaseGetToOneRelatedExecute(r)
}

/*
SubscriptionsPromotedPurchaseGetToOneRelated Method for SubscriptionsPromotedPurchaseGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return SubscriptionsApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest
*/
func (a *SubscriptionsApiService) SubscriptionsPromotedPurchaseGetToOneRelated(ctx context.Context, id string) SubscriptionsApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest {
	return SubscriptionsApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PromotedPurchaseResponse
func (a *SubscriptionsApiService) SubscriptionsPromotedPurchaseGetToOneRelatedExecute(r SubscriptionsApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest) (*PromotedPurchaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PromotedPurchaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsPromotedPurchaseGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/promotedPurchase"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsPromotedPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchases]", r.fieldsPromotedPurchases, "csv")
	}
	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "csv")
	}
	if r.fieldsPromotedPurchaseImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchaseImages]", r.fieldsPromotedPurchaseImages, "csv")
	}
	if r.limitPromotionImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[promotionImages]", r.limitPromotionImages, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionsApiSubscriptionsPromotionalOffersGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *SubscriptionsApiService
	id string
	filterTerritory *[]string
	fieldsSubscriptionPromotionalOffers *[]string
	fieldsSubscriptions *[]string
	fieldsSubscriptionPromotionalOfferPrices *[]string
	limit *int32
	limitPrices *int32
	include *[]string
}

// filter by territory
func (r SubscriptionsApiSubscriptionsPromotionalOffersGetToManyRelatedRequest) FilterTerritory(filterTerritory []string) SubscriptionsApiSubscriptionsPromotionalOffersGetToManyRelatedRequest {
	r.filterTerritory = &filterTerritory
	return r
}

// the fields to include for returned resources of type subscriptionPromotionalOffers
func (r SubscriptionsApiSubscriptionsPromotionalOffersGetToManyRelatedRequest) FieldsSubscriptionPromotionalOffers(fieldsSubscriptionPromotionalOffers []string) SubscriptionsApiSubscriptionsPromotionalOffersGetToManyRelatedRequest {
	r.fieldsSubscriptionPromotionalOffers = &fieldsSubscriptionPromotionalOffers
	return r
}

// the fields to include for returned resources of type subscriptions
func (r SubscriptionsApiSubscriptionsPromotionalOffersGetToManyRelatedRequest) FieldsSubscriptions(fieldsSubscriptions []string) SubscriptionsApiSubscriptionsPromotionalOffersGetToManyRelatedRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// the fields to include for returned resources of type subscriptionPromotionalOfferPrices
func (r SubscriptionsApiSubscriptionsPromotionalOffersGetToManyRelatedRequest) FieldsSubscriptionPromotionalOfferPrices(fieldsSubscriptionPromotionalOfferPrices []string) SubscriptionsApiSubscriptionsPromotionalOffersGetToManyRelatedRequest {
	r.fieldsSubscriptionPromotionalOfferPrices = &fieldsSubscriptionPromotionalOfferPrices
	return r
}

// maximum resources per page
func (r SubscriptionsApiSubscriptionsPromotionalOffersGetToManyRelatedRequest) Limit(limit int32) SubscriptionsApiSubscriptionsPromotionalOffersGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// maximum number of related prices returned (when they are included)
func (r SubscriptionsApiSubscriptionsPromotionalOffersGetToManyRelatedRequest) LimitPrices(limitPrices int32) SubscriptionsApiSubscriptionsPromotionalOffersGetToManyRelatedRequest {
	r.limitPrices = &limitPrices
	return r
}

// comma-separated list of relationships to include
func (r SubscriptionsApiSubscriptionsPromotionalOffersGetToManyRelatedRequest) Include(include []string) SubscriptionsApiSubscriptionsPromotionalOffersGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r SubscriptionsApiSubscriptionsPromotionalOffersGetToManyRelatedRequest) Execute() (*SubscriptionPromotionalOffersResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsPromotionalOffersGetToManyRelatedExecute(r)
}

/*
SubscriptionsPromotionalOffersGetToManyRelated Method for SubscriptionsPromotionalOffersGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return SubscriptionsApiSubscriptionsPromotionalOffersGetToManyRelatedRequest
*/
func (a *SubscriptionsApiService) SubscriptionsPromotionalOffersGetToManyRelated(ctx context.Context, id string) SubscriptionsApiSubscriptionsPromotionalOffersGetToManyRelatedRequest {
	return SubscriptionsApiSubscriptionsPromotionalOffersGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SubscriptionPromotionalOffersResponse
func (a *SubscriptionsApiService) SubscriptionsPromotionalOffersGetToManyRelatedExecute(r SubscriptionsApiSubscriptionsPromotionalOffersGetToManyRelatedRequest) (*SubscriptionPromotionalOffersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionPromotionalOffersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsPromotionalOffersGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/promotionalOffers"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterTerritory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[territory]", r.filterTerritory, "csv")
	}
	if r.fieldsSubscriptionPromotionalOffers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionPromotionalOffers]", r.fieldsSubscriptionPromotionalOffers, "csv")
	}
	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "csv")
	}
	if r.fieldsSubscriptionPromotionalOfferPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionPromotionalOfferPrices]", r.fieldsSubscriptionPromotionalOfferPrices, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.limitPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[prices]", r.limitPrices, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionsApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *SubscriptionsApiService
	id string
	fieldsSubscriptions *[]string
	fieldsSubscriptionLocalizations *[]string
	limit *int32
	include *[]string
}

// the fields to include for returned resources of type subscriptions
func (r SubscriptionsApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest) FieldsSubscriptions(fieldsSubscriptions []string) SubscriptionsApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// the fields to include for returned resources of type subscriptionLocalizations
func (r SubscriptionsApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest) FieldsSubscriptionLocalizations(fieldsSubscriptionLocalizations []string) SubscriptionsApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest {
	r.fieldsSubscriptionLocalizations = &fieldsSubscriptionLocalizations
	return r
}

// maximum resources per page
func (r SubscriptionsApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest) Limit(limit int32) SubscriptionsApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r SubscriptionsApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest) Include(include []string) SubscriptionsApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r SubscriptionsApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest) Execute() (*SubscriptionLocalizationsResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsSubscriptionLocalizationsGetToManyRelatedExecute(r)
}

/*
SubscriptionsSubscriptionLocalizationsGetToManyRelated Method for SubscriptionsSubscriptionLocalizationsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return SubscriptionsApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest
*/
func (a *SubscriptionsApiService) SubscriptionsSubscriptionLocalizationsGetToManyRelated(ctx context.Context, id string) SubscriptionsApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest {
	return SubscriptionsApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SubscriptionLocalizationsResponse
func (a *SubscriptionsApiService) SubscriptionsSubscriptionLocalizationsGetToManyRelatedExecute(r SubscriptionsApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest) (*SubscriptionLocalizationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionLocalizationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsSubscriptionLocalizationsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/subscriptionLocalizations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "csv")
	}
	if r.fieldsSubscriptionLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionLocalizations]", r.fieldsSubscriptionLocalizations, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionsApiSubscriptionsUpdateInstanceRequest struct {
	ctx context.Context
	ApiService *SubscriptionsApiService
	id string
	subscriptionUpdateRequest *SubscriptionUpdateRequest
}

// Subscription representation
func (r SubscriptionsApiSubscriptionsUpdateInstanceRequest) SubscriptionUpdateRequest(subscriptionUpdateRequest SubscriptionUpdateRequest) SubscriptionsApiSubscriptionsUpdateInstanceRequest {
	r.subscriptionUpdateRequest = &subscriptionUpdateRequest
	return r
}

func (r SubscriptionsApiSubscriptionsUpdateInstanceRequest) Execute() (*SubscriptionResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsUpdateInstanceExecute(r)
}

/*
SubscriptionsUpdateInstance Method for SubscriptionsUpdateInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return SubscriptionsApiSubscriptionsUpdateInstanceRequest
*/
func (a *SubscriptionsApiService) SubscriptionsUpdateInstance(ctx context.Context, id string) SubscriptionsApiSubscriptionsUpdateInstanceRequest {
	return SubscriptionsApiSubscriptionsUpdateInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SubscriptionResponse
func (a *SubscriptionsApiService) SubscriptionsUpdateInstanceExecute(r SubscriptionsApiSubscriptionsUpdateInstanceRequest) (*SubscriptionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsUpdateInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subscriptionUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("subscriptionUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.subscriptionUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
